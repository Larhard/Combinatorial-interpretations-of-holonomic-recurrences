\documentclass[final]{article}

\usepackage{todonotes}
\setlength{\marginparwidth}{2.5cm}

\RequirePackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{ }

\RequirePackage{color}
\definecolor{ao(english)}{rgb}{0.0, 0.5, 0.0}
\definecolor{blue(pigment)}{rgb}{0.2, 0.2, 0.6}
\definecolor{egyptianblue}{rgb}{0.06, 0.2, 0.65}

\RequirePackage{listings}
\lstset{
    basicstyle=\small
}

\RequirePackage{geometry}
\RequirePackage{graphicx}

\RequirePackage{amsthm}
\RequirePackage{amsmath}
\RequirePackage{amsfonts}
\RequirePackage{soul}
\RequirePackage{xspace}
\RequirePackage{bussproofs}
\RequirePackage[customcolors]{hf-tikz}

\RequirePackage{tikz}
\RequirePackage{setspace}

\RequirePackage{multicol}
\RequirePackage{lipsum}
\RequirePackage{textpos}

\setlength{\parindent}{0pt}
\setlength{\parskip}{.7em}

\title{Combinatorial interpretations of holonomic recurrences}
\author{Bartłomiej Puget}

% \date{Kraków, 19 maja 2021}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsection]

\theoremstyle{remark}
\newtheorem{example}{Example}[subsection]

\newcounter{highlightid}
\newcommand{\mhl}[1]{{\tikzmarkin[set fill color=red!30,set border color=red]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}

\newcommand{\ols}[1]{\mskip.5\thinmuskip\overline{\mskip-.5\thinmuskip {#1} \mskip-.5\thinmuskip}\mskip.5\thinmuskip} % overline short
\newcommand{\olsi}[1]{\,\overline{\!{#1}}} % overline short italic

\newcommand{\gf}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\enc}[1]{\ensuremath{\ols{#1}}}
\newcommand{\pointed}[1]{\ensuremath{{#1}^*}}
\newcommand{\weighted}[1]{\ensuremath{_{(#1)}}}
\newcommand{\size}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\LambdadB}{\ensuremath{\Lambda_{\text{dB}}}}

\DeclareMathOperator{\textiff}{\text{iff}}
\DeclareMathOperator{\N}{\mathbb{N}}
\DeclareMathOperator{\poly}{\mathbb{P}}
\DeclareMathOperator{\troot}{\text{root}}
\DeclareMathOperator{\tleft}{\text{left}}
\DeclareMathOperator{\tright}{\text{right}}
\DeclareMathOperator{\tLeft}{\text{Left}}
\DeclareMathOperator{\tRight}{\text{Right}}
\DeclareMathOperator{\tSub}{\text{Sub}}
\DeclareMathOperator{\tPre}{\text{Pre}}
\DeclareMathOperator{\tSuf}{\text{Suf}}
\DeclareMathOperator{\n}{\bullet}
\DeclareMathOperator{\no}{\o}

\begin{document}

\begin{titlepage}
	\begin{center}
	\textsc{\LARGE Jagiellonian University}

	\Large Faculty of Mathematics and Computer Science

	\Large Theoretical Computer Science

	\vfill

	\vspace{1cm}
	\hrulefill
	\vspace{0.5cm}

    \makeatletter
    \huge \textsc{\@title}
    \makeatother

	\vspace{0.2cm}
	\hrulefill

	\vspace{1cm}
    \makeatletter
	\textsc{\Large \@author}
    \makeatother

	\vspace{1cm}
    \normalsize

	Master Thesis\\
	Advisor: \textsc{Katarzyna Grygiel}

	\vfill

    \makeatletter
    \@date
    \makeatother
	\end{center}
\end{titlepage}

\section*{Abstract}%
\label{sec:abstract}

We analyze the problem of finding combinatorial interpretations of holonomic recurrences and show some techniques that were used to achieve known results.

We also try to find combinatorial interpretation of holonomic recurrence for trees of lambda terms in de Bruijn notation.

\clearpage

\tableofcontents
\clearpage

\section{Introduction}%
\label{sec:introduction}

\subsection{Notation}%
\label{sub:notation}

In order to make reading of this article easier, let's fix some notation and make some assumptions. Any deviation from this will be clearly stated. If you have trouble guessing what some letter or word means, this should be your primary place to look for the answer.

\(\textiff\) means if and only if.

\(\poly\) is a set of all polynomials.

\(n, m, i, j, k\) are implicitly assumed to be natural numbers.

\(f, g\) are implicitly assumed to be functions.

\(f^{(n)}\) is implicitly defined as \(n\)-th derivative of function \(f\).

\(V(T)\) is implicitly defined as a set of nodes of the tree \(T\).

\(E(T)\) is implicitly defined as a set of edges of the tree \(T\).

\(u, v\) are implicitly assumed to be a nodes.

\(e\) is implicitly assumed to be an edge.

\(\troot(T)\) is implicitly defined as a root of tree \(T\).

\(\tleft(v)\) is implicitly defined as a left child of node \(v\).

\(\tright(v)\) is implicitly defined as a right child of node \(v\).

\(\tSub(v)\) is implicitly defined as a whole subree rooted with node \(v\).

\(\tLeft(v)\) is implicitly defined as a left subree of node \(v\).

\(\tRight(v)\) is implicitly defined as a right subree of node \(v\).

Sibling of node \(v\) is defined as node \(u\) having the same parent as \(v\).

Uncle of node \(v\) is defined as sibling of the parent of \(v\).

We say that node \(v\) is an oneling \(\textiff\) \(v\) has no sibling. Note that the root is oneling even if it has no parent.

We say that node \(v\) is twinling \(\textiff\) \(v\) has at least one sibling.

We say that node \(v\) is an virtual-oneling \(\textiff\) \(v\) has no sibling being virtual node.

We say that node \(v\) is virtual-twinling \(\textiff\) \(v\) has at least one sibling being virtual node.

Leaf is a node which has no children.

\(\n\) is implicitly defined as a default identifier a node.

\(\no\) is implicitly defined as a identifier of non-existing node (eg.\ if \(v\) is a leaf, \(\tleft(v) = \n\)).

Virtual node is artificially defined node that does not affect the structure definition (eg.\ we can define virtual leafs that are children of actual leaves of the binary tree. Such virtual leaves are not included when counting number of children of the node, so the actual leaves are still called leaves).

Actual node is a node that is not virtual.

We say that node \(v\) is right (left) \(\textiff\) \(v\) is a right (left) child of its parent.

We say that node \(v\) has a right (left) parent \(u\) \(\textiff\) \(v\) is a left (right) child of \(u\).

\(\pointed{v}\) is implicitly defined as a pointed node \(v\).

\(v\weighted{n}\) is implicitly defined as a weighted node \(v\) with weight \(n\).

\(x_i\) is implicitly assumed to be \(i\)-th element of the sequence \(X\), where \(x\) can be any lower-case letter and \(X\) is upper-case \(x\).

Calligraphic \(\gf{X}\) is implicitly assumed to be a generating function of the sequence \(X\) where \(X\) is any upper-case letter.

\(\size{X}\) is implicitly defined as a size of the object \(X\).

eg.\ stands for Latin exampli gratia, which means \textit{for example}.

ie.\ stands for Latin id est, which means \textit{that is}.

\subsection{Structurally recursive objects}%
\label{sub:structurally_recursive_objects}

We will be analyzing structures that can be expressed using recursive expressions. Eg.\ we can define full binary tree recursively as a node having no children (ie.\ being a leaf) or having exactly two subtrees being full binary trees. To express the alternative in the construction rule, we use \(+\). The reason will become obvious soon.

\[B = \text{leaf} + B^2\]

\todo{Add some image}

\subsection{Generating functions}%
\label{sub:generating_functions}

In the article we use ordinary generating functions to describe and count structures.

\begin{definition}
The ordinary generating function of sequence \(A = (a_i)_{i=0}^{\infty}\) is defined as:
\[\gf{A}(z) = \sum_{i=0}^{\infty} a_i z^i\]
\end{definition}

Note that in order to compute \(k\)-th element of the sequence, \(a_k\), we just need to find constant corresponding to indeterminate \(z^k\).

\begin{example}
    \label{ex:bin_gf}
    Having our recursive definition of the object, we can easily construct a generating function for it. Let's create generating function that will count number of full binary trees consisting of exactly \(k\) internal nodes.

\[\gf{B}(z) = 1 + z\gf{B}^2(z)\]

Note that we used \(z\) to count internal nodes and left the leaf part as \(1\).

In order to get some intuition on how it works unbeneath, let's take a look on how we can find number of the full binary trees of size \(2\). We can expand the recurrence a bit:

\[\begin{array}{rcl}
        \gf{B}(z) &=& 1 + z\gf{B}^2(z)\\
                  &=& 1 + z\bigg(1 + z\gf{B}^2(z)\bigg)\bigg(1 + z\gf{B}^2(z)\bigg)\\
                  &=& 1 + \mhl{z}\bigg(1 + \mhl{z}\Big(\mhl{1} + z\gf{B}^2(z)\Big)\Big(\mhl{1} + z\gf{B}^2(z)\Big)\bigg)\bigg(\mhl{1} + z\gf{B}^2(z)\bigg)
\end{array}\]

The highlighted terms are describing following tree:

iilll\todo{Add image}
\end{example}

There exist multiple well-known methods and tools that allow us to work with generating functions without need of digging into details. The tool we will be using extensively in this work is Maple package called GFUN\cite{gfun}.

\subsection{Holonomic recurrences}%
\label{sub:holonomic_recurrences}

Most of the time we will be working with holonomic recurrences, let's introduce them.

\begin{definition}
    \label{def:holo_1}
    \cite{holotoolkit}
    An infinite sequence \(A = (a_i)_{i=0}^{\infty}\) is holonomic (aka. P-finite, P-recursive or D-recursive) \(\textiff\) exists holonomic recurrence for it, ie.:

\[\exists_{r \in \N} \exists_{p_0, \ldots, p_r \in \poly} \forall_{n \in \N} \sum_{i=0}^r p_i(n)a_{n+i} = 0\]
\end{definition}

Note that the sum can only take finite number of subsequent elements of the sequence \(A\) into the relation.

\begin{example}
    \(a_n = \frac{5n - 3}{3n + 5}\) is holonomic, because:
    \[(3n + 5)(5n + 2) a_n - (5n - 3)(3n + 8) a_{n+1} = 0\]
\end{example}

\begin{example}
    Sequences \(a_n = \sqrt{n}\), \(b_n = n^n\) are \textbf{not} holonomic, ie. none of them satisifies a linear recurrence equation with polynomial coefficients\cite{nonholo}.
\end{example}

\begin{definition}
    \label{def:holo_2}
    \cite{complexity}
    Equivalently to definition\ \ref{def:holo_1}, \(A = (a_i)_{i=0}^{\infty}\) is holonomic \(\textiff\) exists generating function in the following form:
    \[\sum_{i=0}^{r} p_i(z) \gf{A}^{(i)}(z) = b(z)\]
    for some fixed \(r \in \N\); \(b, p_0, \ldots, p_r \in \poly\) not all identically zero.
\end{definition}

Equivalence of these two definitions assures us that if we find generating function describing the desired objects satisfying definition\ \ref{def:holo_2}, we will be able to find holonomic recurrence mentioned in definition\ \ref{def:holo_1}.\cite{complexity}

\begin{example}
    \label{ex:gfun-rec}
    For generating function full binary trees defined in example\ \ref{ex:bin_gf}, ie.:
    \[\gf{B}(z) = 1 + z\gf{B}^2(z)\]
    we can use GFUN\cite{gfun} to immediately find holonomic recurrence of our interest:

    \begin{lstlisting}
> with(gfun):
> RootOf(B = B^2*z + 1, B);
             2
    RootOf(_Z  z - _Z + 1)

> algfuntoalgeq(%, B(z));
     2
    B  z - B + 1

> algeqtodiffeq(%, B(z));
                              2      /d      \
    1 + (-1 + 2 z) B(z) + (4 z  - z) |-- B(z)|
                                               \dz     /

> rec := diffeqtorec(%, B(z), B(n));
    rec := {(2 + 4 n) B(n) + (-2 - n) B(n + 1), B(0) = 1}
    \end{lstlisting}

    Our holonomic recurrence is then:
    \[\left\{\begin{array}{rcl}
                B(0) &=& 1\\
                (2 + 4 n) B(n) + (-2 - n) B(n + 1) &=& 0
    \end{array}\right.\]

    For our purposes we will often ignore the initial conditions, as they can be easily described by exact number of the objects. The most interesting part for us is the relation between the finite number consecutive elements.

\end{example}

\subsection{Combinatorial interpretations}%
\label{sub:combinatorial_interpretations}

Combinatorial interpretation is just fancy name for something you probably know and use. Eg.\ if you know the binomial coefficient \(\binom{n}{k}\), I bet it was introduced to you as something like: "let's assume you have \(n\) distinguishable balls. If you want to choose \(k\) from them, then you can do it in \(\binom{n}{k}\) ways" and now, whenever you see the term \(\binom{n}{k}\) you interpret it as number of ways to choose \(k\) objects from the set of size \(n\). This is the combinatorial interpretation of the binomial coefficient.

Holonomic recurrences are very useful if we want to count objects of given size. Of course, size can be defined in more complex ways, eg.\ we may want to find number of trees with \(n\) internal nodes having exactly \(m\) nodes beging left child of its parent.

Unfortunately, as for the most of auto-generated code, they almost never come with intuitive interpretation. They are just some recurrences, but there is no commonly known method to find, how they correspond to the structures they describe.

In the article we try to gather methods and results that may be helpful for anyone who will try to find such interpretation, as we believe that such interpretation may give better insight into the nature of the structure and make it easier to study its behaviour.

\subsection{Pre-order notation}%
\label{sub:pre_order_notation}



In order to make notation easier and unambiguous, we also introduce pre-order notation of \(n\)-ary tree.

\begin{definition}
    \(\enc{v}\) is an identifier of node \(v\). 
\end{definition}

\begin{definition}
    Pre-order notation of \(n\)-ary tree \(T\), \(\enc{T}\), is defined recursively as \(\enc{\troot(T)} \prod_{i=1}^{n} \enc{i\text{-th subtree of } \troot(T)}\), ie.\ catenation of identifier of the root of the tree with encoded its subtrees from left to right.
\end{definition}

\begin{example}
    \(\n \n \no \n \no \no \no\)
    \todo{Add image}
\end{example}

We also can define prefix and suffix of \(T\).

\begin{definition}
    Let \(k\) be the index of its identifier in \enc{T}. Notation of prefix of \(T\) in relation to \(v\), \(\enc{\tPre(T, v)}\), is defined as a prefix of \enc{T} of size \(k - 1\).
\end{definition}

\begin{definition}
    Let \(n\) be the size of \enc{T}. Notation of suffix of \(T\) in relation to \(v\), \(\enc{\tSuf(T, v)}\), is defined as a suffix of \enc{T} of size \(n - \size{\enc{\tPre(T, v)}} - \size{\enc{\tSub(v)}}\).
\end{definition}

In the article we define some operations using its notation. As pre-order notation is bijective, you can obtain the structure the notation describe by reversing the process of encoding.

\section{Known results}%
\label{sec:known_results}

\subsection{Binary trees}%
\label{sub:binary_trees}



Let's start with probably the most known result, full binary trees\cite{binary}.

We define the size of tree as a number of internal nodes (ie.\ nodes that are not leaves). Our generating function is therefore:

\[\gf{B}(z) = 1 + z\gf{B}^2(z)\]

After a quick transformation, we get following holonomic recurrence:

\[(n + 2)B(n + 1) = 2 (2n + 1)B(n)\]

This recurrence describes also Catalan numbers.

It is easy to see that tree of size \(n\) (\(n\) internal nodes) has \(n + 1\) leaves and therefore \(2n + 1\) nodes in total. Analogically the tree of size \(n + 1\) has \(n + 2\) leaves and \(2n + 3\) nodes in total. If you see some resemblence to our holonomic recurrence, you are perfectly right.

We are going to create bijection between left and right side of the recurrence. We will be using term \textit{bijective language} to describe talking about the recurrence using the objects it describes and their transformations.

Let's translate the recurrence to the bijective language then.
\begin{itemize}
    \item \(B(n)\) is simply set of all full binary trees of size \(n\),
    \item \((n + 2) B(n + 1)\) is set of all full binary trees of size \(n + 1\) with one of the leaves pointed,
    \item \((2n + 1) B(n)\) is set of all full binary trees of size \(n\) with one of the nodes pointed (remember that the node can be internal node or leaf),
    \item \(2\) at the beginning of \(2 (2n + 1) B(n)\) means that we will be using \(2\) copies of the set defined in previous bullet.
\end{itemize}

At the moment left side of the recurrence describe set of trees of size \(n + 1\), the right, on the other hand, of size \(n\). Therefore, we need to apply some transformation to make the sets equal.

Let's define two local operations: \(R_l(T, v)\) and \(R_r(T, v)\). The term \textit{local} means that the operation can operate on just some finite fragment of tree with predefined size (eg.\ node and its 2 children, but can not traverse the whole tree).

\begin{definition}
    \(\enc{R_l(T, v)} = \enc{\tPre(T, v)} \n \pointed{\n} \no \no \enc{\tSub(v)} \enc{\tSuf(T, v)}\)
\end{definition}

\begin{definition}
    \(\enc{R_r(T, v)} = \enc{\tPre(T, v)} \n \enc{\tSub(v)} \pointed{\n} \no \no \enc{\tSuf(T, v)} \)
\end{definition}

\todo{Add some illustration}

We can now take the bijective interpretation of \((2n + 1) B(n)\), ie. trees of size \(n\) with single node pointed. For each of such trees, \(T\) we create new one by applying \(R_l\) and \(R_r\) to the pair \(T', v\), where \(T'\) is \(T\) with removed pointers and \(v\) is a node that is pointed in \(T\). Therefore we generate \(2(2n + 1) B(n)\) trees of size \(n + 1\)

The only thing that's left for us to verify is if we generate all trees of size \(n + 1\) with pointed leaf. As from the recursion, we know that \(2 (2n + 1) B(n)\) is total number of trees with single leaf pointed, it is enough to check if we do not generate any duplicate using \(R_l\) and \(R_r\). It can happen in 2 ways:
\begin{enumerate}
    \item operation itself generates duplicates or
    \item 2 different operations generate the same tree.
\end{enumerate}

First case can be also split into 2 subcases. Without loss of the generality we can analyze just one of the operations, let it be \(R_l\). The second case will be symmetric.
\begin{itemize}
    \item for some nodes \(u \neq v\), \(R_l(T, u) = R_l(T, v)\). Let \(i_u, i_v\) be the indices of respectively \(\enc{u}\) and \(\enc{v}\) in \(\enc{T}\). Let \(\pointed{i}_u, \pointed{i}_v\) be the indices of pointed node respectively in \(\enc{R_l(T, u)}\) and \(\enc{R_l(T, v)}\). Due to the definition of \(R_l\), we get that \(\pointed{i}_u = i_u + 1\) and \(\pointed{i}_v = i_v + 1\), which implies that \(u = v\) what we assumed false.
    \item for some trees \(T \neq S\), \(R_l(T, u) = R_l(S, v)\). Let \(i_u, i_v\) be the indices of respectively \(\enc{u}\) in \(\enc{T}\) and \(\enc{v}\) in \(\enc{S}\). Let \(\pointed{i}_u, \pointed{i}_v\) be the indices of pointed node respectively in \(\enc{R_l(T, u)}\) and \(\enc{R_l(S, v)}\). If \(\pointed{i}_u \neq \pointed{i}_v\), this case is trivially false, so we can assume that \(\pointed{i}_u = \pointed{i}_v\). Therefore, again from the definition of \(R_l\), we have that \(i_u = i_v\). That implies that \(\enc{\tPre(T, u)} \enc{\tSub(u)} \enc{\tSuf(T, u)} = \enc{\tPre(S, v)} \enc{\tSub(v)} \enc{\tSuf(S, v)} \), which then sums up to \(\enc{T} = \enc{S}\), which we assumed false.
\end{itemize}

In the second case it is enough to noitice that \(R_l\) generates trees with pointed node being a left child, and \(R_r\) generates trees with pointed node being right child. That immediately provides us with conclusion that we are generating no duplicates.

\subsection{Unary-binary trees}%
\label{sub:unary_binary_trees}

Let's think, what would have changed if we introduce unary nodes to the binary case\cite{motzkin}. We will be counting edges. Note that tree having \(n\) edges has exactly \(n + 1\) nodes.

\begin{definition}
    Unary-binary tree is such tree of which any node can have either 0, 1 or 2 children.
\end{definition}

We can easily derive the generating function:

\[\gf{U}(z) = 1 + z\gf{U}(z) + z^2 \gf{U}^2(z)\]

And with a bit of Maple magic, we immediately get following recurrence:

\[(n + 2)U(n) = (2n + 1)U(n - 1) + 3(n - 1)U(n - 2)\]

The definition above is precise, but introduces a new kind of vertice that we would have to take care of. We can avoid it by using a trick to make the tree recall binary tree. We don't change the structure, just the notation.

\begin{definition}
    \label{def:unary_binary_2}
    Left-leaning binary tree\todo{find official name; skewed binary tree is something different} is a binary tree with following constraint added: if a node has right child, it also have a left child.
\end{definition}

The bijection between unary-binary and left-leaning binary trees is very simple. We just represent unary nodes as nodes with just left child of left-leaning binary tree. The other cases translate immediately to corresponding ones. Please note that this transformation keeps the size of the tree (ie.~number of edges).

The next step is to make binary trees full. Let's just define virtual leaves.

\begin{definition}
    Virtual leaf is a virtual node added to the node in place of non-existing child.
\end{definition}

As we have added \(n + 2\) virtual nodes, we have added as much virtual edges.

\todo{image of transformation unary-binary to full-binary}

Please note that \(n + 2\) matches the multiplier of \(U(n)\). Let's point the virtual leaves then.

To present the interpretation in bijective language, we will have to introduce several types of the the virtual leaves (you may want to revisit section \ref{sub:notation} Notation):

\begin{enumerate}
    \item Vro - virtual leaf being right virtual-oneling;
    \item Vrt - virtual leaf being right virtual-twinling. We will divide this case into:
        \begin{enumerate}
            \item VrtUrv - Vri which uncle is a right virtual leaf;
            \item VrtUra - Vri which uncle is a right actual node;
            \item VrtUla - Vri which uncle is a left actual node.
        \end{enumerate}
    \item Vlt - virtual leaf left virtual-twinling. Note that from definition \ref{def:unary_binary_2}, left virtual leave can not have sibling being a actual node. We can divide also this case into:
        \begin{enumerate}
            \item VltUrv - Vlt which uncle is a right virtual leaf;
            \item VltUra - Vlt which uncle is a right actual node;
            \item VltUla - Vlt which uncle is a left actual node.
        \end{enumerate}
\end{enumerate}

Note that it covers all possible cases of pointing virtual leaf and all the cases are mutually disjoint.

All we need to show are the transformations from the smaller cases, ie. \(U(n-1)\) and \(U(n-2)\).

Let's start from \(U(n-1)\). Its multiplier is \(2n + 1\). It suggests that we can point any node, as in a tree having \(n - 1\) edges, we have \(n\) actual and \(n + 1\) virtual ones.

In case of \(U(n-2)\), the multiplier is \(3(n-1)\), that suggests that we should perform \(3\) transformations on the trees with a pointed actual node.

\todo{draw the transformations}

As you can see, we have satisfied all of the cases of \(U(n)\) with no repetitions, which concludes the construction.

\subsection{Schröder trees}%
\label{sub:schröder_trees}

The next case we will show is case of Schröder trees\cite{schroder}.

\begin{definition}
    Schröder tree is a tree with no unary nodes.
\end{definition}

Simply speaking, node can have zero or strictly more than one children.

\todo{example}

This definition is quite precise, but is difficult to implement as a structural recursion. Let's transform it into something more manageable, ie.~of finite arity.

\begin{definition}
    Well-weighted binary plane tree is a weighted tree such that:
    \begin{itemize}
        \item leaves are unweighted;
        \item internal nodes can have weight either \(1\) or \(2\);
        \item if internal node has weight 2, then its right child is not a leaf.
    \end{itemize}
\end{definition}

We can easily define the bijection \(\Phi\) between these two models using pre-order notation:
\[\Phi(T) = \left\{\begin{array}{lcl}
            \n \no \no &:& T = \n \no \no \\
            \n\weighted{1}\; T_1\; T_2 &:& T = \n\; T_1\; T_2\\
            \n\weighted{2}\; T_1\; \Phi(\n\; T_2 \ldots T_n) &:& T = \n\; T_1\; T_2 \ldots T_n
\end{array}\right.\]

Let's define size as a number of leaves. Note that the size is independent from which construction we use, as the leaf is translated to leaf and the internal node to internal nodes.

The generating function equation is then:

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}_1(z) + \gf{T}_2(z) + z\\
            \gf{T}_1(z) &=& \gf{T}^2(z)\\
            \gf{T}_2(z) &=& \gf{T}(z)(\gf{T}_1(z) + \gf{T}_2(z))
\end{array}\right.\]

To be able to use Maple to generate the recurrence, we need to transform this system of equations to a single one. We can eliminate \(\gf{T}_1(z)\) first.

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}^2(z) + \gf{T}_2(z) + z\\
            \gf{T}_2(z) &=& \gf{T}(z)(\gf{T}^2(z) + \gf{T}_2(z))
\end{array}\right.\]

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}^2(z) + \gf{T}_2(z) + z\\
            \gf{T}_2(z)(1 - \gf{T}(z)) &=& \gf{T}^3(z)
\end{array}\right.\]

As we can not use division to get \(\gf{T}_2(z)\), let's multiply the first equation by \(1 - \gf{T}(z)\).

\[\gf{T}(z)(1 - \gf{T}(z)) = \gf{T}^2(z)(1 - \gf{T}(z)) + \gf{T}^3(z) + z(1 - \gf{T}(z))\]

It can be actually used now to generate the holonomic recurrence.

\begin{lstlisting}
> with(gfun):
> RootOf(T*(1 - T) = T^2*(1 - T) + T^3 + z*(1 - T),  T);
               2
    RootOf(2 _Z  + (-z - 1) _Z + z)

> algfuntoalgeq(%, T(z));
       2
    2 T  + (-z - 1) T + z

> algeqtodiffeq(%, T(z));
                               2            /d      \                    2
    {z - 1 + (-z + 3) T(z) + (z  - 6 z + 1) |-- T(z)|, T(0) = RootOf(2 _Z  - _Z)}
                                            \dz     /

> diffeqtorec(%, T(z), T(n));

    {(n - 1) T(n) + (-3 - 6 n) T(n + 1) + (n + 2) T(n + 2), ...}

> subs(n = n - 1, %);

    {(-2 + n) T(n - 1) + (3 - 6 n) T(n) + (n + 1) T(n + 1), ...}
\end{lstlisting}

We can also move \(\gf{T}(z)\) to the other side, ie.:

\[3 (2 n - 1) T(n) = (n - 2) T(n - 1) + (n + 1) T(n + 1)\]

This may seem counterintuitive, as by default we want to describe how to generate larger case from the smaller ones, but it will make the interpretation simpler.

Let's translate the recurrence to the bijective language then.
\begin{itemize}
    \item \((2 n - 1) T(n)\) describes well-weighted binary plane trees of size \(n\) (ie. with \(n\) leaves) with some node pointed (internal or leaf),
    \item \((n + 1) T(n + 1)\) describes well-weighted binary plane trees of size \(n - 1\) with some leaf pointed,
    \item \((n - 2) T(n - 1)\) describes well-weighted binary plane trees of size \(n - 1\) with some internal node pointed.
\end{itemize}

We will show the bijection between two sides of the recursion. We will transform each tree from \((2 n - 1) T(n)\) in three ways in order to achieve all trees from \((n + 1) T(n + 1)\). We will get some extra ones which are not well-weighted, but we will deal with them in a minute.

Let's define 3 transformations: \(L_1\), \(L_2\) and \(R_1\).

\todo{image of the transformations}

You can see that trees generated by \(L_1\) and \(R_1\) are always well-weighted. The problem appears when applying \(L_2\) when \(s\) is a leaf.

When \(s\) is a leaf, we will look at the \(s\)'s parent. It can fall into one of following cases:

\todo{image of the problematic cases}

where \(t'\) can be any tree and \(t''\) can not be a leaf.

When aplying \(L_2\) we achieve following cases respectively:

\todo{images}

In case 1. and 2. we can just swap the labels as follows:

\todo{images}

It is easy to show that it constructs bijection between \((n + 1) T(n + 1)\) and subset of \(\{L_1, L_2, R_1\} \times (2 n - 1) T(n)\) not falling into case 3.

To achive trees from \((n - 2) T(n - 1)\), we can simply take trees from case 3. and replace the father of the \(s\) with \(t''\) and point root of \(t''\). In this way, we will loose \(2\) leaves and obtain each tree from \((n - 2) T(n - 1)\).

\todo{image}

\section{Approaches}%
\label{sec:approaches}

\subsection{Introduction}%
\label{sub:introduction}

As you could see in the examples above, most of the solutions base on the simple analysis of number of laves, internal nodes and other similar properties. In this section, we've gathered some methods that may be helpful when trying to analyze the problem of interpreting combinatorically some holonomic recurrence.

\subsection{Defining the size carefully}%
\label{sub:defining_the_size_carefully}

First thing that we have to select is defining the size carrefully. We have few standard choices of computing tree sizes:
\begin{itemize}
    \item counting all existing nodes,
    \item counting internal nodes,
    \item counting leaves,
    \item counting null-nodes (ie.\ children of the leaves),
    \item edges.
\end{itemize}

It may seem counter-intuitive at first, that this changes anything crucial, but the holonomic recurrence may change drastically making the problem more difficult than it should be.

There are 2 most common symptoms that we may want to choose different method of counting the size:
\begin{itemize}
    \item we get empty classes of the objects, eg.\ if we analyze problem of full binary trees and define size as number of all existing nodes, we can not generate tree of even size, therefore half of our classes are empty;
    \item we want to join trees using common root and we get many \(\pm1\) in our notes. Note that if you count internal nodes, such catenation creates tree of size being sum of sizes of the components increases by 1. If you had defined the size as number of leaves or null-nodes, the size would be just plain sum of sizes of the smaller trees. \todo{Add some example}
\end{itemize}

\subsection{Tree binarization}%
\label{sub:tree_binarization}

If we describe some structure we may be tempted to use multiple kinds of nodes, eg.~unary and binary nodes. Having multiple kinds of nodes may cause problems, both in creating holonomic recurrence and finding the interpretation, as we have to keep track of how they can transform.

As the most common trees are binary ones, it may be worth an effort to find the some structure based on binary trees that can represent original structure (see section~\ref{sub:unary_binary_trees}).

\subsection{Weights variablization}%
\label{sub:weights_variablization}

Most of the time we are operating on trees with some nodes of weight \(0\) and some of weight \(1\). We may as well try to make them variable or assign some other values (eg.\ small prime numbers).

This method gives us some suggestion which kind of nodes are being modified in the operation

Another benefit of this method is decreasing the sizes of particular classes, so we have less objects to look at.

Unfortunately, decreasing size of the classes increases number of the sizes we need to analyze to get full result.

\todo{Add some example}

\subsection{Inductive translation}%
\label{sub:inductive_translation}

Another method that may help finding the interpretation is inductive translation\cite{doron}. The method is based on the idea that most of the time there is easy to find some natural induction (not necessarily holonomic) that has trivial interpretation in bijective language.

\todo{describe binary trees example}

The method itself has proven to be helpful in order to divide the problem into smaller parts. Unfortunately It does not give any immediate interpretation for applying the inductive step.

\section{Brutal iterative approach}%
\label{sec:brutal_iterative_approach}

If all elaborate methods has failed and the problem is still too big to interpret it by hand, a computer comes handy.

As the main field of our interest was analyzis of terms of lambda trees in unary de Bruijn notation, we will use it as an example to describe the method.\todo{Add definition}

\subsection{Lambda terms}%
\label{sub:lambda_terms}

\begin{definition}
    Set of lambda terms \(\Lambda\) is defined recursively:
    \begin{itemize}
        \item if \(x\) is a variable, \(x \in \Lambda\)
        \item if \(M, N \in \Lambda\), then \((M N) \in \Lambda\) (application of function \(M\) to an argument \(N\))
        \item if \(x\) is a variable and \(M \in \Lambda\), then \((\lambda x . M) \in \Lambda\) (abstraction, ie.\ creating a function with an argument \(x\) and binding each occurence of \(x\) in \(M\) to this argument)
    \end{itemize}
\end{definition}

The definition above is quite popular, but introduces several problems. One of them is problem of potential collision of lambda-abstracted variables and difficulty of finding to which lambda abstraction is the variable is bound (or is it even free variable, ie.\ not bound). To address that, we can use de Bruijn indices.

\begin{definition}
    Set of lambda terms \(\LambdadB\) is defined recursively:
    \begin{itemize}
        \item if \(n \in \N\), \(n \in \LambdadB\) (\(n\) is a variable bound to lambda abstraction \(n\) levels above)
        \item if \(M, N \in \LambdadB\), then \((M N) \in \LambdadB\) (application)
        \item if \(M \in \LambdadB\), then \((\lambda M) \in \LambdadB\) (abstraction)
    \end{itemize}
\end{definition}

As you can see, we managed to eliminate the arbitrary variables. We can also easily check if given variable is bound by checking its depth.

\begin{example}
    \(\lambda x . \lambda y . x\) is equivalent to \(\lambda \lambda 1\)
\end{example}

\begin{example}
    \(\lambda x . (\lambda y . x) (\lambda y . y)\) is equivalent to \(\lambda (\lambda 1) (\lambda 0)\)
\end{example}

It also allows us to define tree representation of the terms.

\begin{definition}
    Injection from lambda terms in de Bruijn notation to binary trees \(\Phi\) is defined as follows:
    \begin{itemize}
        \item \(\Phi(0) = \n\; \no\; \no\)
        \item \(\Phi(n) = \n\; \no\; \Phi(n - 1)\)
        \item \(\Phi(\lambda M) = \n\; \Phi(M)\; \no\)
        \item \(\Phi(M N) = \n\; \Phi(M)\; \Phi(N)\)
    \end{itemize}
\end{definition}

To simplify the interpretation, we can introduce several kinds of the nodes: \(o\), \(s\), \(l\) and \(a\). They do not change the structure, but make the reading a bit easier:

\begin{definition}
    \(o\) is a leaf.
\end{definition}

\begin{definition}
    \(s\) is a node with just right child.
\end{definition}

\begin{definition}
    \(l\) is a node with just left child.
\end{definition}

\begin{definition}
    \(a\) is a node with both children.
\end{definition}

Which leads to following interpreation of \(\Phi\):

\begin{itemize}
    \item \(\Phi(0) = o\; \no\; \no\)
    \item \(\Phi(n) = s\; \no\; \Phi(n - 1)\)
    \item \(\Phi(\lambda M) = l\; \Phi(M)\; \no\)
    \item \(\Phi(M N) = a\; \Phi(M)\; \Phi(N)\)
\end{itemize}

You can note that not every binary tree represents valid term.

\begin{example}
    \(\n\; \no\; \n\; \n\; \no\; \no\; \no\) does not represent valid lambda term.
\end{example}

To see that, we can take a look at this tree with our node kinds used:
    \[s\; \no\; l\; o\; \no\; \no\; \no\]

\(s\) represents successor which can be applied only to \(n \in \N\), but is applied to lambda-abstracted term.

\subsection{Enhanced holonomic reccurence}%
\label{sub:enhanced_holonomic_reccurence}

As we have our structure defined, let's create generating functions that will keep track of more than just number of nodes, but also counts of each kind of nodes in the tree. The generating function will be parameterized then using following arguments:
\begin{itemize}
    \item \(z\) counting total number of virtual leaves
    \item \(o\) counting number of bound variable nodes
    \item \(l\) counting number of lambda abstraction nodes
    \item \(a\) counting number of application nodes
    \item \(s\) counting number of successors of bound variable nodes
\end{itemize}

In order to make the image cleaner, we will drop the arguments of generating functions, ie. \(\gf{L} := \gf{L}(z, o, l, a, s)\)
\[\gf{L} = z a \gf{L}^2 + z l \gf{L} + \frac{o z}{1 - z s}\]
\todo{add some image}
\todo{describe how the frac is generated}

Using a little bit of Maple magic, we can easily achieve following holonomic recurrence.

\[\begin{array}{rl}
        & (n - 4) l^2 s^2 L(n - 4)\\
        +& ((4 n - 10) a o s - (2 n - 6) l^2 s - (2 n - 5) l s^2) L(n - 3)\\
        +& ((-4 n + 8) a o + (n - 2) l^2 + (4 n - 6) l s + (n - 1) s^2) L(n - 2)\\
        +& ((-2 n + 1) l - 2 n s) L(n - 1)\\
        +& (n + 1) L(n)
\end{array}\]

Appearing in the recurrence node kinds mean that we extend trees of given size using nodes of that kinds.

\begin{example}
    \((2n - 5) l s^2 L(n - 3)\) mean extending each tree of size \((n - 3)\) pointed in \((2n - 5)\) ways using single \(l\) node and two \(s\) nodes.
\end{example}

You may notice that some potentially trivial terms are more complex that it seems. If we didn't count different types of nodes, we would achieve following holonomic recurrence:

\[\begin{array}{rl}
        & (n - 4) L(n - 4)\\
        +& L(n - 3)\\
        +& (2 n - 1) L(n - 2)\\
        +& (-4 n + 1) L(n - 1)\\
        +& (1 + n) L(n)
\end{array}\]

\begin{example}
    \(L(n-3)\) is expanded into \(((4 n - 10) a o s - (2 n - 6) l^2 s - (2 n - 5) l s^2) L(n - 3)\).
\end{example}


\subsection{The framework}%
\label{sub:the_framework}

We also created a framework that may help visualize our work. It is based on the idea that every transformation described using bijective language can be translated to a function transforming node and finite number of its surrounding nodes. This function can not discriminate nodes on the grounds of their kind. The only discrimination that may occur may be connected to the following cases:
\begin{itemize}
    \item node has no children, ie.~is a virtual leaf (which corresponds to the size of the tree, \(n\));
    \item node has has children, ie.~is not a virtual leaf (which corresponds to \(n - 1\));
    \item node has its parent on the left, ie.~is right child of its parent;
    \item node has its parent on the right, ie.~is left child of its parent.
\end{itemize}

The latest two are intruduced in order to make the analysis simpler, but do not have immediate interpretation in the world of holonomic recurrences. If we use them both, it sums up to all nodes except root (as root is neither left nor right child).


\subsection{Transformation classes}%
\label{sub:transformation_classes}

We will be operating on transformation classes, sections and parts. Let's define them:

\begin{definition}
    Class \(T_i\) is defined as set of transformations of trees of size \((n - i)\) into trees of size \(n\).
\end{definition}

\begin{definition}
    Section \(T_{i,j}\) is defined as subset of \(T_i\) adding specific set of nodes. We assign \(j\) according to the lexicographical order of lexicographically sorted node types.
\end{definition}

\begin{definition}
    Part \(T_{i,j,k}\) is defined as single transformation in section \(T_{i,j}\). \(k\) is assigned according to the order of discovering the transformation.
\end{definition}

In order to make interpretation more human readable, we will be using local notation:

\begin{definition}
    In context of \(T_i\), \(k\) is defined as \((n - i)\).
\end{definition}

\begin{definition}
    In context of \(T_i\), \(C_k\) is defined as \(L(n - i)\), ie.\ number of trees transformations from \(T_i\) are working on.
\end{definition}

\begin{definition}
    Section equation \(E_{i, j}\) is an equation defined in context of \(T_i\) that evaluates to a total number of trees that should be generated by transformations from \(T_{i, j}\).
\end{definition}

\begin{definition}
    Section expression \(S_{i, j}\) is pair of section equation and set of kinds of nodes the transformation introduces.
\end{definition}

For the problem of interpreting trees of lambda terms we define following section expressions:

\[\begin{array}{rccrlc}
        S_{0,0} &=& (& (k + 1) C_k,& \emptyset &)\\
        S_{1,0} &=& (& - (2 k + 1) C_k,& \{l\} &)\\
        S_{1,1} &=& (& - 2 (k + 1) C_k,& \{s\} &)\\
        S_{2,0} &=& (& - (4 k) C_k,& \{aou\} &)\\
        S_{2,1} &=& (& (k) C_k,& \{ll\} &)\\
        S_{2,2} &=& (& (4 k + 2) C_k,& \{ls\} &)\\
        S_{2,3} &=& (& (k + 1) C_k,& \{ss\} &)\\
        S_{3,0} &=& (& 2 (2 k + 1) C_k,& \{aosu\} &)\\
        S_{3,1} &=& (& - (2 k) C_k,& \{lls\} &)\\
        S_{3,2} &=& (& - (2 k + 1) C_k,& \{lss\} &)\\
        S_{4,0} &=& (& k C_k,& \{llss\} &)\\
\end{array}\]

Using context-based variables makes the equation simpler to interpret, as we can immediately see relation between \(k\) and multiplier.

\subsection{Iteration}%
\label{sub:iteration}

As we want to make our work kind of organized, we are going to divide the process into iterations. Each iteration should be a small step into direction of solving the original problem.

We are going to generate two kinds of trees. Positive and negative ones. When computing total number of trees, we count positive tree is counted as \(1\), negative as \(-1\). Our goal is to generate \(E_{i, j}\) trees for each section \(T_{i, j}\).

We start with interpreting \(E_{0,0}\).

\subsection{The cheat}%
\label{sub:the_cheat}

You may ask how we achieved such partial result.

\section{Further work}%
\label{sec:further_work}

\todo{finish interpretation}
\todo{missing formal proof}

\clearpage

\begin{thebibliography}{9}
    \bibitem{remy}
    Laurent Alonso Alonso, Jean-Luc Remy, and René Schott,
    \textit{A Linear-Time Algorithm for the Generation of Trees},
    Algorithmica 17,
    1997,
    p. 162-182

    \bibitem{motzkin}
    Serge Dulucq, Jean-Guy Penaud,
    \textit{Interprétation bijective d'une récurrence des nombres de Motzkin},
    Discrete Mathematics,
    Volume 256, Issue 3,
    2002,
    p. 671-676

    \bibitem{schroder}
    Dominique Foata, Doron Zeilberger,
    \textit{A Classic Proof of a Recurrence for a Very Classical Sequence}
    J. Comb., Ser. A, 80,
    1997, 380-384

    \bibitem{binary}
    Jean-Luc Rémy,
    \textit{Un procédé itératif de dénombrement d’arbres binaires et son application à leur génération aléatoire}
    Informatique théorique, tome 19, no 2, 
    1985,
    p. 179-195

    \bibitem{doron}
    Doron Zeilberger,
    \textit{e-mail conversation},
    2020

    \bibitem{note}
    Jarmo Siltaneva, Erkki Mäkinen,
    \textit{A Note on Rémy's Algorithm for Generating Random Binary Trees},
    Missouri Journal of Mathematical Sciences. 15. 103-109. 10.35834/2003/1502103,
    2003 

    \bibitem{bodini}
    Axel Bacher, Olivier Bodini, Alice Jacquot,
    Efficient random sampling of binary and unary-binary trees via holonomic equations,
    2014

    \bibitem{complexity}
    Igor Pak,
    \textit{Complexity problems in enumerative combinatorics},
    2018

    \bibitem{gfun}
    Bruno Salvy, Paul Zimmermann,
    \textit{GFUN : a maple package for the manipulation of generating and holonomic functions in one variable}
    [Research Report] RT-0143, INRIA. 1992, pp.14. ffinria-00070025f

    \bibitem{holotoolkit}
    Manuel Kauers,
    \textit{The Holonomic Toolkit},
    in: Carsten Schneider, Johannes Blümlein (eds) Computer Algebra in Quantum Field Theory. Texts \& Monographs in Symbolic Computation (A Series of the Research Institute for Symbolic Computation, Johannes Kepler University, Linz, Austria),
    Springer, Vienna,
    2013

    \bibitem{nonholo}
    Stefan Gerhold,
    \textit{Combinatorial sequences: Non-holonomicity and inequalities. Ph.D. thesis},
    RISC-Linz, Johannes Kepler Universitat Linz,
    2005

\end{thebibliography}

\end{document}
