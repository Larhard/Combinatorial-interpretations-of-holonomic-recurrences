\documentclass[final]{article}

\usepackage{todonotes}
\setlength{\marginparwidth}{2.5cm}

\RequirePackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{ }
\DeclareUnicodeCharacter{25CF}{\(\n\)}

\RequirePackage{color}
\definecolor{ao(english)}{rgb}{0.0, 0.5, 0.0}
\definecolor{blue(pigment)}{rgb}{0.2, 0.2, 0.6}
\definecolor{egyptianblue}{rgb}{0.06, 0.2, 0.65}
\definecolor{lightgray}{gray}{0.60}

\RequirePackage{listings}
\lstset{
    basicstyle=\footnotesize\ttfamily,
    comment=[l]{\#},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{lightgray}\ttfamily,
    escapeinside={<@}{@>}
}

\RequirePackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    filecolor=black,
    urlcolor=black
}

\RequirePackage{geometry}
\RequirePackage{tabularx}
\RequirePackage{longtable}
\RequirePackage{graphicx}
\RequirePackage{svg}

\svgpath{images/}

\RequirePackage{amsthm}
\RequirePackage{amsmath}
\RequirePackage{mathtools}
\RequirePackage{amsfonts}
\RequirePackage{soul}
\RequirePackage{xspace}
\RequirePackage{bussproofs}
\RequirePackage[customcolors]{hf-tikz}

\RequirePackage{tikz}
\RequirePackage{setspace}

\RequirePackage{multicol}
\RequirePackage{lipsum}
\RequirePackage{textpos}

\setlength{\parindent}{0pt}
\setlength{\parskip}{.7em}

\title{Combinatorial interpretations of holonomic recurrences}
\author{Bartłomiej Puget}

\date{\today}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsection]

\theoremstyle{remark}
\newtheorem{example}{Example}[subsection]

\newcounter{highlightid}
\newcommand{\mhl}[1]{{\tikzmarkin[set fill color=red!30,set border color=red]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}

\newcommand{\ols}[1]{\mskip.5\thinmuskip\overline{\mskip-.5\thinmuskip {#1} \mskip-.5\thinmuskip}\mskip.5\thinmuskip} % overline short
\newcommand{\olsi}[1]{\,\overline{\!{#1}}} % overline short italic

\newcommand{\gf}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\enc}[1]{\ensuremath{\ols{#1}}}
\newcommand{\pointed}[1]{\ensuremath{{#1}^*}}
\newcommand{\weighted}[1]{\ensuremath{_{(#1)}}}
\newcommand{\size}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\LambdadB}{\ensuremath{\Lambda_{\text{dB}}}}

\DeclareMathOperator{\textiff}{\text{iff}}
\DeclareMathOperator{\N}{\mathbb{N}}
\DeclareMathOperator{\poly}{\mathbb{P}}
\DeclareMathOperator{\troot}{\text{root}}
\DeclareMathOperator{\tleft}{\text{left}}
\DeclareMathOperator{\tright}{\text{right}}
\DeclareMathOperator{\tLeft}{\text{Left}}
\DeclareMathOperator{\tRight}{\text{Right}}
\DeclareMathOperator{\tSub}{\text{Sub}}
\DeclareMathOperator{\tPre}{\text{Pre}}
\DeclareMathOperator{\tSuf}{\text{Suf}}
\DeclareMathOperator{\n}{\bullet}
\DeclareMathOperator{\no}{\o}

\newcommand{\includeinlinesvg}[2]{\begin{minipage}{#1\textwidth}\includesvg[width=\textwidth]{#2}\end{minipage}}
\newcommand{\includeinlinescaledsvg}[3]{\begin{minipage}{#1\textwidth}\begin{center}\includesvg[scale=#2]{#3}\end{center}\end{minipage}}

\begin{document}

\begin{titlepage}
	\begin{center}
	\textsc{\LARGE Jagiellonian University}

	\Large Faculty of Mathematics and Computer Science

	\Large Theoretical Computer Science

	\vfill

	\vspace{1cm}
	\hrulefill
	\vspace{0.5cm}

    \makeatletter
    \huge \textsc{\@title}
    \makeatother

	\vspace{0.2cm}
	\hrulefill

	\vspace{1cm}
    \makeatletter
	\textsc{\Large \@author}
    \makeatother

	\vspace{1cm}
    \normalsize

	Master Thesis\\
	Advisor: \textsc{Katarzyna Grygiel}

	\vfill

    \makeatletter
    \@date
    \makeatother
	\end{center}
\end{titlepage}

\section*{Abstract}%
\label{sec:abstract}

We analyze the problem of finding combinatorial interpretations of holonomic recurrences and show some techniques that were used to achieve known results.

We also try to find a combinatorial interpretation of the holonomic recurrence for trees of lambda terms in the de Bruijn notation.

\clearpage

\tableofcontents
\clearpage

\section{Overview}%

Every recursive structure can be described using a generating function, which can be then transformed into holonomic recurrence. It allows us to quickly count objects of given structure with given size. At first glance, the recurrence seems to be closely related to the structure itself. It just seems like it should describe simple transformations, like adding some vertices to the smaller trees. Although, there is no known method of interpreting it in the language of the combinatorial structures.

Initial inspiration for the thesis came from publication \textit{A natural counting of lambda terms}\cite{zigzag}, which shows bijection between seemingly different tree structures, which are lambda trees, black-white trees and zigzag free trees. They share the same holonomic recurrence, but there is no known immediate connection between the holonomic recurrence and the structure itself.

Throughout the thesis we try to accumulate known results and techniques that may help solving the problem of finding combinatorial interpretations. We also propose an approach that helped us to find an intermediate solution for the problem of finding combinatorial interpretation for holonomic recurrence of lambda trees in the unary de Bruijn notation.

In the section\ \ref{sec:introduction} we establish notation nad introduce concepts that will be using throughout the thesis.

Next, in the section \ref{sec:known_results}, we present known results. They demonstrate combinatorial interpretations that reflect different approaches.

In the section\ \ref{sec:approaches} we show approaches to the problem that helped people achieve their results. All of them were tried in order to find the answer to the original problem of interpreting holonomic recurrence of trees of lambda terms in the unary de Bruijn notation. Unfortunately none of them helped us enough to get the final result. They are proven to be helpful when we are stuck though as most of them are able to divide problems into smaller parts and detect corner cases.

Section\ \ref{sec:brutal_iterative_approach} presents our final approach to the original problem, i.e.\ computer-aided iterative approach that allowed us to find the intermediate solution. We believe that it is able to provide us with the full solution, but we were not able to achieve that due to the limited time that was available to us.

Finally, in section\ \ref{sec:further_work}, we present our view on what can be done with the problem in the future. We believe that one day the problem will be fully solved and a more generic approach to interpreting holonomic recurrences will emerge.

\clearpage

\section{Introduction}%
\label{sec:introduction}

\subsection{Notation}%
\label{sub:notation}

In order to make reading this thesis easier, let's fix some notation and make some assumptions. Any deviation from this will be clearly stated. If you have trouble guessing what some letter or word means, this should be your primary place to look for the answer.

\(\textiff\) means if and only if.

\(\poly\) is a set of all polynomials.

\(n, m, i, j, k\) are implicitly assumed to be natural numbers.

\(f, g\) are implicitly assumed to be functions.

\(f^{(n)}\) is implicitly defined as \(n\)-th derivative of function \(f\).

\(V(T)\) is implicitly defined as a set of nodes of the tree \(T\).

\(E(T)\) is implicitly defined as a set of edges of the tree \(T\).

\(u, v\) are implicitly assumed to be nodes.

\(e\) is implicitly assumed to be an edge.

\(\troot(T)\) is implicitly defined as a root of tree \(T\).

\(\tleft(v)\) is implicitly defined as a left child of node \(v\).

\(\tright(v)\) is implicitly defined as a right child of node \(v\).

\(\tSub(v)\) is implicitly defined as a whole subtree rooted with node \(v\).

\(\tLeft(v)\) is implicitly defined as a left subtree of node \(v\).

\(\tRight(v)\) is implicitly defined as a right subtree of node \(v\).

Sibling of node \(v\) is defined as node \(u\) having the same parent as \(v\).

Uncle of node \(v\) is defined as a sibling of the parent of \(v\).

We say that node \(v\) is an oneling \(\textiff\) \(v\) has no siblings. Note that the root is oneling even if it has no parent.

We say that node \(v\) is twinling \(\textiff\) \(v\) has at least one sibling.

Leaf is a node which has no children.

\(\n\) is implicitly defined as a default identifier of a node.

\(\no\) is implicitly defined as an identifier of a non-existing node (e.g.\ if \(v\) is a leaf, \(\tleft(v) = \n\)).

Dashed edges 
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__dashed_edge}
\end{minipage}
depict edges that may or may not exist (e.g.\ when we describe transformations and we do not care if the node is root or if it has children).

Green edges 
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__green_edge}
\end{minipage}
depict edges to \(\no\) nodes.

Virtual node is an artificially defined node that does not affect the structure definition (e.g.\ we can define virtual leafs that are children of actual leaves of the binary tree. Such virtual leaves are not included when counting the number of children of the node, so the actual leaves are still called leaves).

Actual node is a node that is not virtual.

We say that node \(v\) is an virtual-oneling \(\textiff\) \(v\) has no siblings being virtual nodes.

We say that node \(v\) is virtual-twinling \(\textiff\) \(v\) has at least one sibling being virtual node.

For a binary tree, we say that node \(v\) is right (left) \(\textiff\) \(v\) is a right (left) child of its parent.

For a binary tree, we say that node \(v\) has a right (left) parent \(u\) \(\textiff\) \(v\) is a left (right) child of \(u\).

\(\pointed{v}\) is implicitly defined as a pointed node \(v\). We can treat it as a node with an additional label \(\pointed{}\).

\(v\weighted{n}\) is implicitly defined as a weighted node \(v\) with weight \(n\).

\(x_i\) is implicitly assumed to be an \(i\)-th element of the sequence \(X\), where \(x\) can be any lower-case letter and \(X\) is upper-case \(x\).

Calligraphic \(\gf{X}\) is implicitly assumed to be a generating function of the sequence \(X\) where \(X\) is any upper-case letter.

\(\size{X}\) is implicitly defined as the size of the object \(X\).

e.g.\ stands for Latin exempli gratia, which means \textit{for example}.

i.e.\ stands for Latin id est, which means \textit{that is}.
\todo{It should be obvious, but people mix them up}

\subsection{Structurally recursive objects}%
\label{sub:structurally_recursive_objects}

We will be analyzing structures that can be expressed using recursive formulas. Eg.\ we can define a full binary tree recursively as a node having no children (i.e.\ being a leaf) or having exactly two subtrees being full binary trees. To express the alternative in the construction rule, we use \(+\). The reason will become obvious soon.

\begin{figure}[h]
    \begin{center}
        \begin{minipage}[t]{.2\textwidth}
            \begin{center}
                \(B\)\\
                \includesvg[scale=0.5]{binary__def_1}%
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.05\textwidth}
            \begin{center}
                \(=\)\\
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.2\textwidth}
            \begin{center}
                \(\text{leaf}\)\\
                \includesvg[scale=0.5]{binary__def_2}%
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.05\textwidth}
            \begin{center}
                \(+\)\\
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.2\textwidth}
            \begin{center}
                \(B^2\)\\
                \includesvg[scale=0.5]{binary__def_3}%
            \end{center}
        \end{minipage}%
    \end{center}
    \caption{Binary tree recursive definition}
    \label{fig:binary_recursion}
\end{figure}

\subsection{Generating functions}%
\label{sub:generating_functions}
\todo{Make the section simpler}

Throughout the thesis we use ordinary generating functions to describe and count structures.

\begin{definition}
The ordinary generating function of sequence \(A = (a_i)_{i=0}^{\infty}\) is defined as:
\[\gf{A}(z) = \sum_{i=0}^{\infty} a_i z^i\]
\end{definition}

Note that in order to compute the \(k\)-th element of the sequence, namely \(a_k\), we just need to find a constant corresponding to indeterminate \(z^k\).

\begin{example}
    \label{ex:bin_gf}
    Having our recursive definition of the object, we can easily construct a generating function for it. Let's create a generating function that will count the number of full binary trees consisting of exactly \(k\) internal nodes.\todo{define sequence for the structure}

\[\gf{B}(z) = 1 + z\gf{B}^2(z)\]

Note that we used \(z\) to mark internal nodes. Leaves are of size \(0\), so they are marked using \(z^0 = 1\).

In order to get some intuition on how it works underneath, let's take a look at how we can find the number of full binary trees of size \(2\). We can expand the recurrence a bit:

\[\begin{array}{rcl}
        \gf{B}(z) &=& 1 + z\gf{B}^2(z)\\
                  &=& 1 + z\bigg(1 + z\gf{B}^2(z)\bigg)\bigg(1 + z\gf{B}^2(z)\bigg)\\
                  &=& 1 + \mhl{z}\bigg(1 + \mhl{z}\Big(\mhl{1} + z\gf{B}^2(z)\Big)\Big(\mhl{1} + z\gf{B}^2(z)\Big)\bigg)\bigg(\mhl{1} + z\gf{B}^2(z)\bigg)
\end{array}\]

The highlighted terms describe following tree:

\begin{center}
    \includesvg[scale=.7]{intro__iilll}
\end{center}
\end{example}

There exist multiple well-known methods and tools that allow us to work with generating functions without the need of digging into details. The tool we will be using extensively in this work is the Maple package called GFUN\cite{gfun}. If you want to learn more about algorithms used in the package, we strongly encourage reading the referenced article.

\subsection{Holonomic recurrences}%
\label{sub:holonomic_recurrences}
\todo{Extend the section}

Most of the time we will be working with holonomic recurrences, let's introduce them.

\begin{definition}[\cite{holotoolkit}]
    \label{def:holo_1}
    An infinite sequence \(A = (a_i)_{i=0}^{\infty}\) is holonomic (aka. P-finite, P-recursive or D-recursive) \(\textiff\) there exists a holonomic recurrence for it, i.e.:

\[\exists_{r \in \N} \exists_{p_0, \ldots, p_r \in \poly} \forall_{n \in \N} \sum_{i=0}^r p_i(n)a_{n+i} = 0\]
\end{definition}

Note that the sum can only take a finite number of subsequent elements of the sequence \(A\) into the relation.

\begin{example}
    The sequence \(a_n = \frac{5n - 3}{3n + 5}\) is holonomic, because it satisifies:
    \[(3n + 5)(5n + 2) a_n - (5n - 3)(3n + 8) a_{n+1} = 0\]
\end{example}

\begin{example}
    Sequences \(a_n = \sqrt{n}\), \(b_n = n^n\) are \textbf{not} holonomic, i.e.\ none of them satisfies a linear recurrence equation with polynomial coefficients\cite{nonholo}.
\end{example}

\begin{definition}[\cite{complexity}]
    \label{def:holo_2}
    Equivalently to definition\ \ref{def:holo_1}, \(A = (a_i)_{i=0}^{\infty}\) is holonomic \(\textiff\) there exists a generating function in the following form:
    \[\sum_{i=0}^{r} p_i(z) \gf{A}^{(i)}(z) = b(z)\]
    for some fixed \(r \in \N\); \(b, p_0, \ldots, p_r \in \poly\) not all identical to zero.
\end{definition}

The equivalence of these two definitions assures us that if we find generating function describing the desired objects satisfying definition\ \ref{def:holo_2}, we will be able to find holonomic recurrence mentioned in definition\ \ref{def:holo_1}.\cite{complexity}

\begin{example}
    \label{ex:gfun-rec}
    For generating function full binary trees defined in example\ \ref{ex:bin_gf}, i.e.:
    \[\gf{B}(z) = 1 + z\gf{B}^2(z)\]
    we can use GFUN\cite{gfun} to immediately find holonomic recurrence of our interest:

    \begin{lstlisting}
> with(gfun):
> RootOf(B = B^2*z + 1, B);
             2
    RootOf(_Z  z - _Z + 1)

> algfuntoalgeq(%, B(z));
     2
    B  z - B + 1

> algeqtodiffeq(%, B(z));
                              2      /d      \
    1 + (-1 + 2 z) B(z) + (4 z  - z) |-- B(z)|
                                     \dz     /

> rec := diffeqtorec(%, B(z), B(n));
    rec := {(2 + 4 n) B(n) + (-2 - n) B(n + 1), B(0) = 1}
    \end{lstlisting}

    Our holonomic recurrence is then:
    \[\left\{\begin{array}{rcl}
                B(0) &=& 1\\
                (2 + 4 n) B(n) + (-2 - n) B(n + 1) &=& 0
    \end{array}\right.\]

    For our purposes we will often ignore the initial conditions, as they can be easily described by the exact number of the objects. The most interesting part for us is the relation between the finite number consecutive elements.

\end{example}

\subsection{Combinatorial interpretations}%
\label{sub:combinatorial_interpretations}

Combinatorial interpretation is just a fancy name for something you probably know and use. Eg.\ if you know the binomial coefficient \(\binom{n}{k}\), I bet it was introduced to you as something like: "let's assume you have \(n\) distinguishable balls. If you want to choose \(k\) from them, then you can do it in \(\binom{n}{k}\) ways" and now, whenever you see the term \(\binom{n}{k}\) you interpret it as number of ways to choose \(k\) objects from the set of size \(n\). This is the combinatorial interpretation of the binomial coefficient.

Holonomic recurrences are very useful if we want to count objects of given size. Of course, size can be defined in more complex ways, e.g.\ we may want to find the number of trees with \(n\) internal nodes having exactly \(m\) nodes being left child of its parent.

Unfortunately, as for most auto-generated code, they almost never come with intuitive interpretation. They are just some recurrences, but there is no commonly known method to find how they correspond to the structures they describe.

In the thesis we try to gather methods and results that may be helpful for anyone trying to find such interpretation, as we believe that such interpretation may give better insight into the nature of the structure and make it easier to study its behaviour.

\subsection{Pre-order notation}%
\label{sub:pre_order_notation}



In order to make notation easier and unambiguous, we also introduce pre-order notation of \(n\)-ary tree.

\begin{definition}
    \(\enc{v}\) is an identifier of node \(v\). 
\end{definition}

\begin{definition}
    Pre-order notation of \(n\)-ary tree \(T\), \(\enc{T}\), is defined recursively as:
    \[\enc{T} = \enc{\troot(T)} \prod_{i=1}^{n} \enc{i\text{-th subtree of } \troot(T)}\]
    i.e.\ catenation of the identifier of the root of the tree with encoded its subtrees from left to right.
\end{definition}

\begin{figure}[h]
    \centering
    \includesvg[scale=.7]{intro__oononnn}
    \caption{\(\n \n \no \n \no \no \no\)}
    \label{fig:oononnn}
\end{figure}

We can also define prefixes and suffixes of \(T\).

\begin{definition}
    Let \(k\) be the index of its identifier in \enc{T}. Notation of prefix of \(T\) in relation to \(v\), \(\enc{\tPre(T, v)}\), is defined as a prefix of \enc{T} of size \(k - 1\).
\end{definition}

\begin{definition}
    Let \(n\) be the size of \enc{T}. Notation of suffix of \(T\) in relation to \(v\), \(\enc{\tSuf(T, v)}\), is defined as a suffix of \enc{T} of size \(n - \size{\enc{\tPre(T, v)}} - \size{\enc{\tSub(v)}}\).
\end{definition}

Throughout thesis we define some operations using this notation. As pre-order notation is bijective, you can obtain the structure the notation describes by reversing the process of encoding.

\section{Known results}%
\label{sec:known_results}

\subsection{Binary trees}%
\label{sub:binary_trees}



Let's start with probably the most known result, full binary trees\cite{binary}.

We define the size of a tree as a number of internal nodes (i.e.\ nodes that are not leaves). Our generating function is therefore:

\[\gf{B}(z) = 1 + z\gf{B}^2(z)\]

After a quick transformation, we get following holonomic recurrence:

\[(n + 2)B(n + 1) = 2 (2n + 1)B(n)\]

This recurrence also describes Catalan numbers.

It is easy to see that a tree of size \(n\) (i.e.\ with \(n\) internal nodes) has \(n + 1\) leaves and therefore \(2n + 1\) nodes in total. Analogically the tree of size \(n + 1\) has \(n + 2\) leaves and \(2n + 3\) nodes in total. If you see some resemblance to our holonomic recurrence, you are perfectly right.

We are going to create a bijection between the left and right side of the recurrence. We will be using the term \textit{bijective language} to talk about the recurrence using the objects it describes and their transformations.

Let's translate the recurrence to the bijective language then.
\begin{itemize}
    \item \(B(n)\) is simply set of all full binary trees of size \(n\),
    \item \((n + 2) B(n + 1)\) is set of all full binary trees of size \(n + 1\) with one of the leaves pointed,
    \item \((2n + 1) B(n)\) is set of all full binary trees of size \(n\) with one of the nodes pointed (remember that the node can be internal node or leaf),
    \item \(2\) at the beginning of \(2 (2n + 1) B(n)\) means that we will be using \(2\) copies of the set defined in the previous bullet.
\end{itemize}

At the moment the left side of the recurrence describes a set of trees of size \(n + 1\), the right, on the other hand, of size \(n\). Therefore, we need to apply some transformation to make the sets equal.

Let's define two local operations: \(R_l(T, v)\) and \(R_r(T, v)\). The term \textit{local} means that the operation can operate on just some finite fragment of tree with predefined size (e.g.\ node and its 2 children, but can not traverse the whole tree).

\begin{definition}
    \(\enc{R_l(T, v)} = \enc{\tPre(T, v)} \n \pointed{\n} \no \no \enc{\tSub(v)} \enc{\tSuf(T, v)}\)
\end{definition}

\begin{definition}
    \(\enc{R_r(T, v)} = \enc{\tPre(T, v)} \n \enc{\tSub(v)} \pointed{\n} \no \no \enc{\tSuf(T, v)} \)
\end{definition}

\begin{figure}[h]
    \centering
    \begin{minipage}{.25\textwidth}\includesvg[scale=0.35]{binary__remy_base}\end{minipage}%
    \(\Rightarrow\)
    \begin{minipage}{.4\textwidth}\includesvg[scale=0.5]{binary__remy_left}\end{minipage}%
    \caption{\(\enc{R_l(T, v)}\)}
    \label{fig:remy_left}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{minipage}{.25\textwidth}\includesvg[scale=0.35]{binary__remy_base}\end{minipage}%
    \(\Rightarrow\)
    \begin{minipage}{.4\textwidth}\includesvg[scale=0.5]{binary__remy_right}\end{minipage}%
    \caption{\(\enc{R_r(T, v)}\)}
    \label{fig:remy_right}
\end{figure}

We can now take the bijective interpretation of \((2n + 1) B(n)\), i.e.\ trees of size \(n\) with a single node pointed. For each of such trees, \(T\) we create new one by applying \(R_l\) and \(R_r\) to the pair \(T', v\), where \(T'\) is \(T\) with removed pointers and \(v\) is a node that is pointed in \(T\). Therefore we generate \(2(2n + 1) B(n)\) trees of size \(n + 1\)

The only thing that's left for us to verify is if we generate all trees of size \(n + 1\) with pointed leaves. As from the recursion, we know that \(2 (2n + 1) B(n)\) is total number of trees with single leaf pointed, it is enough to check if we do not generate any duplicate using \(R_l\) and \(R_r\). It can happen in 2 ways:
\begin{enumerate}
    \item operation itself generates duplicates or
    \item 2 different operations generate the same tree.
\end{enumerate}

First case can also be split into 2 subcases. Without loss of generality we can analyze just one of the operations, let it be \(R_l\). The second case is symmetric.
\begin{itemize}
    \item for some nodes \(u \neq v\), \(R_l(T, u) = R_l(T, v)\). Let \(i_u, i_v\) be the indices of respectively \(\enc{u}\) and \(\enc{v}\) in \(\enc{T}\). Let \(\pointed{i}_u, \pointed{i}_v\) be the indices of pointed node respectively in \(\enc{R_l(T, u)}\) and \(\enc{R_l(T, v)}\). Due to the definition of \(R_l\), we get that \(\pointed{i}_u = i_u + 1\) and \(\pointed{i}_v = i_v + 1\), which implies that \(u = v\) what we assumed false.
    \item for some trees \(T \neq S\), \(R_l(T, u) = R_l(S, v)\). Let \(i_u, i_v\) be the indices of respectively \(\enc{u}\) in \(\enc{T}\) and \(\enc{v}\) in \(\enc{S}\). Let \(\pointed{i}_u, \pointed{i}_v\) be the indices of pointed node respectively in \(\enc{R_l(T, u)}\) and \(\enc{R_l(S, v)}\). If \(\pointed{i}_u \neq \pointed{i}_v\), this case is trivially false, so we can assume that \(\pointed{i}_u = \pointed{i}_v\). Therefore, again from the definition of \(R_l\), we have that \(i_u = i_v\). That implies that \(\enc{\tPre(T, u)} \enc{\tSub(u)} \enc{\tSuf(T, u)} = \enc{\tPre(S, v)} \enc{\tSub(v)} \enc{\tSuf(S, v)} \), which then sums up to \(\enc{T} = \enc{S}\), which we assumed false.
\end{itemize}

In the second case it is enough to notice that \(R_l\) generates trees with pointed nodes being a left child, and \(R_r\) generates trees with pointed nodes being right child. That immediately provides us with the conclusion that we are generating no duplicates.

\subsection{Unary-binary trees}%
\label{sub:unary_binary_trees}

Let's think, what would have changed if we introduce unary nodes to the binary case\cite{motzkin}. We will be counting edges. Note that a tree having \(n\) edges has exactly \(n + 1\) nodes.

\begin{definition}
    Unary-binary tree is such tree of which any node can have either 0, 1 or 2 children.
\end{definition}

We can easily derive the generating function:

\[\gf{U}(z) = 1 + z\gf{U}(z) + z^2 \gf{U}^2(z)\]

And with a bit of Maple magic\cite{gfun}, we immediately get following recurrence:

\[(n + 2)U(n) = (2n + 1)U(n - 1) + 3(n - 1)U(n - 2)\]

The definition above is precise, but introduces a new kind of node that we would have to take care of. We can avoid it by using a trick to make the tree recall binary trees. We do not change the structure, just the notation.

\begin{definition}
    \label{def:unary_binary_2}
    Left-leaning binary tree\todo{find official name; skewed binary tree is something different} is a binary tree with the following constraint added: if a node has a right child, it also has a left child.
\end{definition}

The bijection between unary-binary and left-leaning binary trees is very simple. We just represent unary nodes as nodes with just the left child of the left-leaning binary tree. The other cases translate immediately to corresponding ones. Please note that this transformation keeps the size of the tree (i.e.~number of edges).

The next step is to make binary trees full. Let's just define virtual leaves.

\begin{definition}
    Virtual leaf is a virtual node added to the node in place of a non-existing child.
\end{definition}

As we have added \(n + 2\) virtual nodes, we have added as many virtual edges.

\begin{figure}[h]
    \centering
    \includeinlinesvg{.2}{unary_binary__base}%
    \(\Rightarrow\)%
    \includeinlinesvg{.3}{unary_binary__full}
    \caption{Unary-binary tree to full-binary tree transformation}
    \label{fig:unary_binary_transformation}
\end{figure}

Please note that \(n + 2\) matches the multiplier of \(U(n)\). Let's point the virtual leaves then.

To present the interpretation in bijective language, we will have to introduce several types of the the nodes (you may want to revisit section \ref{sub:notation} Notation):

\begin{enumerate}
    \item Vro - virtual leaf being right virtual-oneling;
    \item Vrt - virtual leaf being right virtual-twinling. We will divide this case into:
        \begin{enumerate}
            \item VrtUrv - Vri which uncle is a right virtual leaf;
            \item VrtUra - Vri which uncle is a right actual node;
            \item VrtUla - Vri which uncle is a left actual node.
        \end{enumerate}
    \item Vlt - virtual leaf left virtual-twinling. Note that from definition \ref{def:unary_binary_2}, left virtual leave can not have a sibling being an actual node. We can divide also this case into:
        \begin{enumerate}
            \item VltUrv - Vlt which uncle is a right virtual leaf;
            \item VltUra - Vlt which uncle is a right actual node;
            \item VltUla - Vlt which uncle is a left actual node;
        \end{enumerate}
    \item I - Internal node.
\end{enumerate}

Note that it covers all possible cases of pointing virtual leaf and all the cases are mutually disjoint.

All we need to show are the transformations from the smaller cases, i.e.\ \(U(n-1)\) and \(U(n-2)\).

Let's start from \(U(n-1)\). Its multiplier is \(2n + 1\). It suggests that we can point to any node, as in a tree having \(n - 1\) edges, we have \(n\) actual and \(n + 1\) virtual ones.

In case of \(U(n-2)\), the multiplier is \(3(n-1)\), that suggests that we should perform \(3\) transformations on the trees with a pointed actual node.

\begin{center}
    \begin{longtable}{| c | c | c |}
        \hline

        \(U(n-2)\) &
        \(U(n-1)\) &
        \(U(n)\)\\
        \hline

        &
        I \includesvg[scale=0.4]{unary_binary__1si} &
        Vro \includesvg[scale=0.4]{unary_binary__0fid} \\
        \hline

        &
        Vlt \includesvg[scale=0.4]{unary_binary__1fjg} &
        VrtUrv \includesvg[scale=0.4]{unary_binary__0fjdOgf} \\
        \hline

        I \includesvg[scale=0.4]{unary_binary__2i} &
        &
        VrtUra \includesvg[scale=0.4]{unary_binary__0fjdOdi} \\
        \hline

        &
        Vro \includesvg[scale=0.4]{unary_binary__1fid} &
        VrtUla \includesvg[scale=0.4]{unary_binary__0fjdOgi} \\
        \hline

        &
        Vrt \includesvg[scale=0.4]{unary_binary__1fjd} &
        VltUrv \includesvg[scale=0.4]{unary_binary__0fjgOdf} \\
        \hline

        I \includesvg[scale=0.4]{unary_binary__2i} &
        &
        VltUra \includesvg[scale=0.4]{unary_binary__0fjgOdi} \\
        \hline

        I \includesvg[scale=0.4]{unary_binary__2i} &
        &
        VltUla \includesvg[scale=0.4]{unary_binary__0fjgOgi} \\
        \hline
    \end{longtable}
\end{center}


As you can see, we have satisfied all of the cases of \(U(n)\) with no repetitions, which concludes the construction.

\subsection{Schröder trees}%
\label{sub:schröder_trees}

The next case we will show is the case of Schröder trees\cite{schroder}.

\begin{definition}
    Schröder tree is a tree with no unary nodes.
\end{definition}

Simply speaking, nodes can have zero or strictly more than one child.

\begin{figure}[h]
    \centering
    \includesvg[scale=0.4]{schroder__example_1}
    \includesvg[scale=0.4]{schroder__example_2}
    \includesvg[scale=0.4]{schroder__example_3}
    \includesvg[scale=0.4]{schroder__example_4}
    \(\ldots\)
    \caption{Schröder tree node}
    \label{fig:schroder_trees}
\end{figure}

This definition is quite precise, but is difficult to implement as a structural recursion. Let's transform it into something more manageable, i.e.~of finite arity.

\begin{definition}
    Well-weighted binary plane tree is a weighted tree such that:
    \begin{itemize}
        \item leaves are unweighted;
        \item internal nodes can have weight either \(1\) or \(2\);
        \item if the internal node has weight 2, then its right child is not a leaf.
    \end{itemize}
\end{definition}

We can easily define the bijection \(\Phi\) between these two models using pre-order notation:
\[\Phi(T) = \left\{\begin{array}{lcl}
            \n \no \no &:& T = \n \no \no \\
            \n\weighted{1}\; T_1\; T_2 &:& T = \n\; T_1\; T_2\\
            \n\weighted{2}\; T_1\; \Phi(\n\; T_2 \ldots T_n) &:& T = \n\; T_1\; T_2 \ldots T_n
\end{array}\right.\]

Let's define size as a number of leaves. Note that the size is independent from which construction we use, as the leaf is translated to leaf and the internal node to internal nodes.

The generating function equation is then:

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}_1(z) + \gf{T}_2(z) + z\\
            \gf{T}_1(z) &=& \gf{T}^2(z)\\
            \gf{T}_2(z) &=& \gf{T}(z)(\gf{T}_1(z) + \gf{T}_2(z))
\end{array}\right.\]

To be able to use Maple to generate the recurrence, we need to transform this system of equations to a single one. We can eliminate \(\gf{T}_1(z)\) first.

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}^2(z) + \gf{T}_2(z) + z\\
            \gf{T}_2(z) &=& \gf{T}(z)(\gf{T}^2(z) + \gf{T}_2(z))
\end{array}\right.\]

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}^2(z) + \gf{T}_2(z) + z\\
            \gf{T}_2(z)(1 - \gf{T}(z)) &=& \gf{T}^3(z)
\end{array}\right.\]

As we can not use division to get \(\gf{T}_2(z)\), let's multiply the first equation by \(1 - \gf{T}(z)\).

\[\gf{T}(z)(1 - \gf{T}(z)) = \gf{T}^2(z)(1 - \gf{T}(z)) + \gf{T}^3(z) + z(1 - \gf{T}(z))\]

It can be actually used now to generate the holonomic recurrence.

\begin{lstlisting}
> with(gfun):
> RootOf(T*(1 - T) = T^2*(1 - T) + T^3 + z*(1 - T),  T);
               2
    RootOf(2 _Z  + (-z - 1) _Z + z)

> algfuntoalgeq(%, T(z));
       2
    2 T  + (-z - 1) T + z

> algeqtodiffeq(%, T(z));
                               2            /d      \                    2
    {z - 1 + (-z + 3) T(z) + (z  - 6 z + 1) |-- T(z)|, T(0) = RootOf(2 _Z  - _Z)}
                                            \dz     /

> diffeqtorec(%, T(z), T(n));

    {(n - 1) T(n) + (-3 - 6 n) T(n + 1) + (n + 2) T(n + 2), ...}

> subs(n = n - 1, %);

    {(-2 + n) T(n - 1) + (3 - 6 n) T(n) + (n + 1) T(n + 1), ...}
\end{lstlisting}

We can also move \(T(n)\) to the other side, i.e.:

\[3 (2 n - 1) T(n) = (n - 2) T(n - 1) + (n + 1) T(n + 1)\]

This may seem counterintuitive, as by default we want to describe how to generate larger cases from the smaller ones, but it will make the interpretation simpler.

Let's translate the recurrence to the bijective language then.
\begin{itemize}
    \item \((2 n - 1) T(n)\) describes well-weighted binary plane trees of size \(n\) (i.e.\ with \(n\) leaves) with some node pointed (internal or leaf),
    \item \((n + 1) T(n + 1)\) describes well-weighted binary plane trees of size \(n - 1\) with some leaf pointed,
    \item \((n - 2) T(n - 1)\) describes well-weighted binary plane trees of size \(n - 1\) with some internal node pointed.
\end{itemize}

We will show the bijection between two sides of the recursion. We will transform each tree from \((2 n - 1) T(n)\) in three ways in order to achieve all trees from \((n + 1) T(n + 1)\). We will get some extra ones which are not well-weighted, but we will deal with them in a minute.

Let's define 3 transformations, \(L_1\), \(L_2\) and \(R_1\):

\begin{center}
    \includeinlinesvg{.16}{schroder__lr_base}%
    \(\xRightarrow{L_1}\)%
    \includeinlinesvg{.16}{schroder__l1}%
    \hspace{.1\textwidth}%
    \includeinlinesvg{.16}{schroder__lr_base}%
    \(\xRightarrow{L_2}\)%
    \includeinlinesvg{.16}{schroder__l2}%

    \includeinlinesvg{.16}{schroder__lr_base}%
    \(\xRightarrow{R_1}\)%
    \includeinlinesvg{.16}{schroder__r1}%
\end{center}

You can see that trees generated by \(L_1\) and \(R_1\) are always well-weighted. The problem appears when applying \(L_2\) when \(s\) is a leaf.

When \(s\) is a leaf, we will look at the \(s\)'s parent. It can fall into one of following cases:

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.5]{schroder__case_a}\\
            Case 1.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.5]{schroder__case_b}\\
            Case 2.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.5]{schroder__case_c}\\
            Case 3.
        \end{center}
    \end{minipage}%
\end{center}

where \(t'\) can be any tree and \(t''\) can not be a leaf.

When applying \(L_2\) we achieve following cases respectively:

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_a_l}\\
            Case 1.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_b_l}\\
            Case 2.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_c_l}\\
            Case 3.
        \end{center}
    \end{minipage}%
\end{center}

In case 1.\ and 2.\ we can just swap the labels as follows:

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_a_l_fixed}\\
            Case 1.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_b_l_fixed}\\
            Case 2.
        \end{center}
    \end{minipage}%
\end{center}

It is easy to show that it constructs bijection between \((n + 1) T(n + 1)\) and subset of \(\{L_1, L_2, R_1\} \times (2 n - 1) T(n)\) not falling into case 3. We will show that in a moment.

To achieve trees from \((n - 2) T(n - 1)\), we can simply take trees from case 3.\ and replace whole subtree with subtree of \(t''\) with its root pointed. In this way, we will lose \(2\) leaves and obtain each tree from \((n - 2) T(n - 1)\):

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_c_l_fixed}\\
            Case 3.
        \end{center}
    \end{minipage}%
\end{center}

To see the bijection, we can just draw all possible cases:

\begin{center}
    \begin{longtable}{| c || c | c | c |}
        \hline
        &
        \(R_1\) &
        \(L_1\) &
        \(L_2\) \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__11} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__12} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__13} &
        \begin{minipage}{.25\textwidth}
            \begin{center}
                \includeinlinescaledsvg{1}{.4}{schroder__proof__14}
                \(\Downarrow\)
                \includeinlinescaledsvg{1}{.4}{schroder__proof__14b}
            \end{center}
        \end{minipage}
        \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__21} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__22} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__23} &
        \begin{minipage}{.25\textwidth}
            \begin{center}
                \includeinlinescaledsvg{1}{.4}{schroder__proof__24}
                \(\Downarrow\)
                \includeinlinescaledsvg{1}{.4}{schroder__proof__24b}
            \end{center}
        \end{minipage}
        \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__31} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__32} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__33} &
        \begin{minipage}{.25\textwidth}
            \begin{center}
                \includeinlinescaledsvg{1}{.4}{schroder__proof__34}
                \(\Downarrow\)
                \includeinlinescaledsvg{1}{.4}{schroder__proof__34b}
            \end{center}
        \end{minipage}
        \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__41} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__42} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__43} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__44} \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__51} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__52} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__53} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__54} \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__61} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__62} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__63} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__64} \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__71} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__72} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__73} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__74} \\
        \hline

        \includeinlinescaledsvg{.25}{.4}{schroder__proof__81} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__82} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__83} &
        \includeinlinescaledsvg{.25}{.4}{schroder__proof__84} \\
        \hline

    \end{longtable}
\end{center}

\section{Approaches}%
\label{sec:approaches}

\subsection{Introduction}%
\label{sub:introduction}

As you could see in the examples above, most of the solutions are based on the simple analysis of number of leaves, internal nodes and other similar properties. In this section, we've gathered some methods that may be helpful when trying to analyze the problem of interpreting combinatorially some holonomic recurrence.

\subsection{Defining the size carefully}%
\label{sub:defining_the_size_carefully}

First thing that we have to select is defining the size carefully. We have few standard choices of computing tree sizes:
\begin{itemize}
    \item counting all existing nodes,
    \item counting internal nodes,
    \item counting leaves,
    \item counting null-nodes (i.e.\ children of the leaves),
    \item counting edges.
\end{itemize}

It may seem counterintuitive at first, that this changes anything crucial, but with a change of the size definition, the holonomic recurrence may complicate itself drastically making the problem more difficult than it should be.

There are 2 most common symptoms that we may want to choose different method of counting the size:
\begin{itemize}
    \item we get empty classes of the objects, e.g.\ if we analyze problem of full binary trees and define size as number of all existing nodes, we can not generate tree of even size, therefore half of our classes are empty;
    \item we want to join trees using common roots and we get many \(\pm1\) in our notes. Note that if you count internal nodes, such catenation creates a tree of size being the sum of sizes of the components increased by 1. If you had defined the size as the number of leaves or null-nodes, the size would be just a simple sum of the sizes of the smaller trees.
\end{itemize}

\subsection{Tree binarization}%
\label{sub:tree_binarization}

If we describe some structure we may be tempted to use multiple kinds of nodes, e.g.~unary and binary nodes. Having multiple kinds of nodes may cause problems, both in creating holonomic recurrence and finding the interpretation, as we have to keep track of how they can transform.

As the most common trees are binary ones, it may be worth an effort to find some structure based on binary trees that can represent the original structure (see section~\ref{sub:unary_binary_trees}).

\subsection{Weights variabilization}%
\label{sub:weights_variablization}

Most of the time we are operating on trees with some nodes of weight \(0\) and some of weight \(1\). We may as well try to make them variable or assign some other values (e.g.\ small prime numbers).

This method gives us some suggestion which kind of nodes are being modified in the operation

Another benefit of this method is decreasing the sizes of particular classes, so we have less objects to look at.

Unfortunately, decreasing the size of the classes increases the number of the sizes we need to analyze to get a full result.

In section \ref{sub:lambda_terms} we will define trees of lambda terms. If we would assign following weights to nodes:

\[\begin{array}{rcl}
        a &:& 7\\
        l &:& 5\\
        s &:& 3\\
        o &:& 2\\
\end{array}\]

we would get significantly smaller classes

\begin{longtable}{| c | c |}
    \hline

    Size & Trees
    \\\hline
    
    2 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_002_000000}
    \end{minipage}
    \\\hline

    5 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_005_000000}
    \end{minipage}
    \\\hline

    7 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_007_000000}
    \end{minipage}
    \\\hline

    8 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_008_000000}
    \end{minipage}
    \\\hline

    10 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_010_000000}
    \end{minipage}
    \\\hline

    11 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_011_000000}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_011_000001}
    \end{minipage}
    \\\hline

    12 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_012_000000}
    \end{minipage}
    \\\hline

    14 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000000}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000001}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000002}
    \end{minipage}
    \\\hline

    15 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_015_000000}
    \end{minipage}
    \\\hline

    16 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000000}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000001}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000002}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000003}
    \end{minipage}
    \\\hline

    % 17 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000004}
    % \end{minipage}
    % \\\hline

    % 18 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_018_000000}
    % \end{minipage}
    % \\\hline

    % 19 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000006}
    % \end{minipage}
    % \\\hline

    % 20 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000007}
    % \end{minipage}
    % \\\hline

    % 21 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000006}
    % \end{minipage}
    % \\\hline

    % 22 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000007}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000008}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000009}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000010}
    % \end{minipage}
    % \\\hline

    % 23 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000007}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000008}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000009}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000010}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000011}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000012}
    % \end{minipage}
    % \\\hline

    % 24 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000007}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000008}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000009}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000010}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000011}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000012}
    % \end{minipage}
    % \\\hline
\end{longtable}

Analyzing such small cases is much easier, but on the other hand, there are many more classes that have to be considered to get full interpretation.

\subsection{Inductive translation}%
\label{sub:inductive_translation}

Another method that may help finding the interpretation is inductive translation\cite{doron}. The method is based on the idea that most of the time there is an easy way to find some natural induction (not necessarily holonomic) that has trivial interpretation in bijective language.

For case of binary trees with size defined as number of leaves, we can define 2 recurrences:

\[\text{Holonomic} := nB(n) = 2 (2n - 3)B(n - 1)\]
\[\text{Non-linear} := B(n) = \sum_{i=1}^{n - 1} B(i) B(n - i)\]

The non-linear one has a very simple interpretation. We can take 2 smaller trees and join them using newly created common root.

We can multiply both sides of Non-linear recurrence by \(n\) and break up \(n = i + (n - i)\) to get two similar sigmas:

\[n B(n) = \sum_{i=1}^{n - 1} i B(i) B(n - i) + \sum_{i=1}^{n - 1} (n - i) B(n - i) B(i)\]

Using our inductive hypothesis, i.e.\ holonomic recurrence and moving problematic cases out from the sums (in that case \(B(1)\) needs to be analyzed separately, as we did not define binary trees with no leaves), we can get the right side to use \(B(n - 1)\) and prove that the holonomic recurrence using non-linear one. The only part that is left is to translate this proof to the bijective language, which in such a simple case as binary trees is almost trivial, especially if one has seen the solution once.

The method itself has proven to be helpful in order to divide the problem into smaller parts and find some corner cases. Unfortunately, it does not give any immediate interpretation for applying the inductive step.

\section{Brutal iterative approach}%
\label{sec:brutal_iterative_approach}

If all elaborate methods have failed and the problem is still too big to interpret it by hand, a computer comes in handy.

As the main field of our interest was analysis of terms of lambda trees in unary de Bruijn notation, we will use it as an example to describe the method.

\subsection{Lambda terms}%
\label{sub:lambda_terms}

\begin{definition}
    Set of lambda terms \(\Lambda\) is defined recursively:
    \begin{itemize}
        \item if \(x\) is a variable, \(x \in \Lambda\)
        \item if \(M, N \in \Lambda\), then \((M N) \in \Lambda\) (application of function \(M\) to an argument \(N\))
        \item if \(x\) is a variable and \(M \in \Lambda\), then \((\lambda x . M) \in \Lambda\) (abstraction, i.e.\ creating a function with an argument \(x\) and binding each occurrence of \(x\) in \(M\) to this argument)
    \end{itemize}
\end{definition}

The definition above is quite popular, but introduces several problems. One of them is a problem of potential collision of lambda-abstracted variables and difficulty of finding to which lambda abstraction is the variable bound (or is it even a free variable, i.e.\ not bound). To address that, we can use de Bruijn indices.

\begin{definition}
    Set of lambda terms \(\LambdadB\) is defined recursively:
    \begin{itemize}
        \item if \(n \in \N\), \(n \in \LambdadB\) (\(n\) is a variable bound to lambda abstraction \(n\) levels above)
        \item if \(M, N \in \LambdadB\), then \((M N) \in \LambdadB\) (application)
        \item if \(M \in \LambdadB\), then \((\lambda M) \in \LambdadB\) (abstraction)
    \end{itemize}
\end{definition}

As you can see, we managed to eliminate the arbitrary variables. We can also easily check if a given variable is bound by checking its depth.

\begin{example}
    \(\lambda x . \lambda y . x\) is equivalent to \(\lambda \lambda 1\)
\end{example}

\begin{example}
    \(\lambda x . (\lambda y . x) (\lambda y . y)\) is equivalent to \(\lambda (\lambda 1) (\lambda 0)\)
\end{example}

It also allows us to define tree representation of the terms.

\begin{definition}
    Injection from lambda terms in de Bruijn notation to binary trees \(\Phi\) is defined as follows:
    \begin{itemize}
        \item \(\Phi(0) = \n\; \no\; \no\)
        \item \(\Phi(n) = \n\; \no\; \Phi(n - 1)\)
        \item \(\Phi(\lambda M) = \n\; \Phi(M)\; \no\)
        \item \(\Phi(M N) = \n\; \Phi(M)\; \Phi(N)\)
    \end{itemize}
\end{definition}

To simplify the interpretation, we can introduce several kinds of the nodes: \(o\), \(s\), \(l\) and \(a\). They do not change the structure, but make the reading a bit easier:

\begin{definition}
    \(o\) is a leaf.
\end{definition}

\begin{definition}
    \(s\) is a node with only the right child.
\end{definition}

\begin{definition}
    \(l\) is a node with only the left child.
\end{definition}

\begin{definition}
    \(a\) is a node with both children.
\end{definition}

Which leads to following interpretation of \(\Phi\):

\begin{itemize}
    \item \(\Phi(0) = o\; \no\; \no\)
    \item \(\Phi(n) = s\; \no\; \Phi(n - 1)\)
    \item \(\Phi(\lambda M) = l\; \Phi(M)\; \no\)
    \item \(\Phi(M N) = a\; \Phi(M)\; \Phi(N)\)
\end{itemize}

You can note that not every binary tree represents a valid term.

\begin{example}
    \(\n\; \no\; \n\; \n\; \no\; \no\; \no\) does not represent a valid lambda term.
\end{example}

To see that, we can take a look at this tree with our node kinds used:
    \[s\; \no\; l\; o\; \no\; \no\; \no\]

\(s\) represents the successor which can be applied only to \(n \in \N\), but is applied to the lambda-abstracted term.

\subsection{Enhanced holonomic recurrence}%
\label{sub:enhanced_holonomic_reccurence}

As we have our structure defined, let's create generating functions that will keep track of more than just the number of nodes, but also counts of each kind of node in the tree. The generating function will be parameterized then using following arguments:
\begin{itemize}
    \item \(z\) counting total number of virtual leaves
    \item \(o\) counting number of bound variable nodes
    \item \(l\) counting number of lambda abstraction nodes
    \item \(a\) counting number of application nodes
    \item \(s\) counting number of successors of bound variable nodes
\end{itemize}

In order to make the image cleaner, we will drop the arguments of generating functions, i.e.\ \(\gf{L} := \gf{L}(z, o, l, a, s)\)


\begin{center}
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(\gf{L}\)\\
            \includesvg[scale=0.5]{lambda__def__1}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(=\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z a \gf{L}^2\)\\
            \includesvg[scale=0.5]{lambda__def__2}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(+\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z l \gf{L}\)\\
            \includesvg[scale=0.5]{lambda__def__3}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(+\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(\gf{L'}\)\\
            \includesvg[scale=0.5]{lambda__def__4}%
        \end{center}
    \end{minipage}%
\end{center}

where:

\begin{center}
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(\gf{L'}\)\\
            \includesvg[scale=0.5]{lambda__def__5}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(=\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z s \gf{L'}\)\\
            \includesvg[scale=0.5]{lambda__def__4}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(+\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z o\)\\
            \includesvg[scale=0.5]{lambda__def__6}%
        \end{center}
    \end{minipage}%
\end{center}

After solving the equation for \(\gf{L'}\), we get:
\[\gf{L} = z a \gf{L}^2 + z l \gf{L} + \frac{z o}{1 - z s}\]

Using a little bit of Maple magic\cite{gfun}, we can easily achieve the following holonomic recurrence.

\[\begin{array}{rl}
        0 =& (n - 4) l^2 s^2 L(n - 4)\\
        +& ((4 n - 10) a o s - (2 n - 6) l^2 s - (2 n - 5) l s^2) L(n - 3)\\
        +& ((-4 n + 8) a o + (n - 2) l^2 + (4 n - 6) l s + (n - 1) s^2) L(n - 2)\\
        +& ((-2 n + 1) l - 2 n s) L(n - 1)\\
        +& (n + 1) L(n)
\end{array}\]

Appearing in the recurrence node kinds means that we extend trees of given size using nodes of that kind.

\begin{example}
    \((2n - 5) l s^2 L(n - 3)\) mean extending each tree of size \((n - 3)\) pointed in \((2n - 5)\) ways using single \(l\) node and two \(s\) nodes.
\end{example}

You may notice that some potentially trivial terms are more complex than they seem. If we did not count different types of nodes, we would achieve following holonomic recurrence:

\[\begin{array}{rl}
        0 =& (n - 4) L(n - 4)\\
        +& L(n - 3)\\
        +& (2 n - 1) L(n - 2)\\
        +& (-4 n + 1) L(n - 1)\\
        +& (1 + n) L(n)
\end{array}\]

\begin{example}
    \(L(n-3)\) is expanded into \(((4 n - 10) a o s - (2 n - 6) l^2 s - (2 n - 5) l s^2) L(n - 3)\).
\end{example}


\subsection{The Transformator framework}%
\label{sub:the_framework}

We also created a framework\cite{transformator}, called transformator, that may help visualize our work. It is based on the idea that every transformation described using bijective language can be translated to a function transforming node and finite number of its surrounding nodes. This function can not discriminate between nodes on the grounds of their kind. The only discrimination criteria that may occur may be connected to the following cases:
\begin{itemize}
    \item node has no children, i.e.~is a virtual leaf (which corresponds to the size of the tree, \(n\));
    \item node has has children, i.e.~is not a virtual leaf (which corresponds to \(n - 1\));
    \item node is a root (which corresponds to \(1\));
    \item node has its parent on the left, i.e.~is right child of its parent;
    \item node has its parent on the right, i.e.~is the left child of its parent.
\end{itemize}

The latest two are introduced in order to make the analysis simpler, but do not have immediate interpretation in the world of holonomic recurrences. If we use them both, it sums up to all nodes except root (as root is neither left nor right child).


\subsection{Transformation classes}%
\label{sub:transformation_classes}

We will be operating on transformation classes, sections and parts. Let's define them:

\begin{definition}
    Class \(T_i\) is defined as a set of transformations of trees of size \((n - i)\) into trees of size \(n\).
\end{definition}

\begin{definition}
    Section \(T_{i,j}\) is defined as a subset of \(T_i\) adding a specific set of nodes. Webassign \(j\) according to the lexicographical order of lexicographically sorted node types.
\end{definition}

\begin{definition}
    Part \(T_{i,j,k}\) is defined as a single transformation in section \(T_{i,j}\). \(k\) is assigned according to the order of discovering the transformation.
\end{definition}

In order to make interpretation more human readable, we will be using local notation:

\begin{definition}
    In the context of \(T_i\), \(k\) is defined as \((n - i)\).
\end{definition}

\begin{definition}
    In the context of \(T_i\), \(C_k\) is defined as \(L(n - i)\), i.e.\ number of tree transformations from \(T_i\) are working on.
\end{definition}

\begin{definition}
    Section equation \(E_{i, j}\) is an equation defined in the context of \(T_i\) that evaluates to a total number of trees that should be generated by transformations from \(T_{i, j}\).
\end{definition}

\begin{definition}
    Section expression \(S_{i, j}\) is a pair of section equations and a set of kinds of nodes the transformation introduces.
\end{definition}

For the problem of interpreting trees of lambda terms we define following section expressions:

\[\begin{array}{rccrlc}
        S_{0,0} &=& (& (k + 1) C_k,& \emptyset &)\\
        S_{1,0} &=& (& - (2 k + 1) C_k,& \{l\} &)\\
        S_{1,1} &=& (& - 2 (k + 1) C_k,& \{s\} &)\\
        S_{2,0} &=& (& - (4 k) C_k,& \{ao\} &)\\
        S_{2,1} &=& (& (k) C_k,& \{ll\} &)\\
        S_{2,2} &=& (& (4 k + 2) C_k,& \{ls\} &)\\
        S_{2,3} &=& (& (k + 1) C_k,& \{ss\} &)\\
        S_{3,0} &=& (& 2 (2 k + 1) C_k,& \{aos\} &)\\
        S_{3,1} &=& (& - (2 k) C_k,& \{lls\} &)\\
        S_{3,2} &=& (& - (2 k + 1) C_k,& \{lss\} &)\\
        S_{4,0} &=& (& k C_k,& \{llss\} &)\\
\end{array}\]

Using context-based variables makes the equation simpler to interpret, as we can immediately see the relation between \(k\) and multiplier.

\subsection{Iteration}%
\label{sub:iteration}

As we want to make our work kind of organized, we are going to divide the process into iterations. Each iteration should be a small step into the direction of solving the original problem.

We are going to generate two kinds of trees. Positive and negative ones. When computing the total number of trees, we count positive trees as \(1\) and negative as \(-1\). Our goal is to generate \(E_{i, j}\) trees for each section \(T_{i, j}\).

Our brains like small examples, so we will consider small \(n = 3\). This will cause some classes to be empty at the beginning, but it's ok. That's less trees to look at.


\begin{lstlisting}
=== Classes stats ===
[ ]  0,0:       0 of      16 | (k + 1) * Ck              []
[ ]  1,0:       0 of     -10 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:       0 of     -12 | - 2 * (k + 1) * Ck        [s]
[ ]  2,0:       0 of      -4 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of       1 | (k) * Ck                  [ll]
[ ]  2,2:       0 of       6 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of       2 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of       2 | 2 * (2 * k + 1) * Ck      [aos]
[x]  3,1:       0 of       0 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of      -1 | - (2 * k + 1) * Ck        [lss]
[x]  4,0:       0 of       0 | k * Ck                    [llss]
\end{lstlisting}

This statistic tells us for each section, how many trees have been generated of the expected total number of trees in that section. \verb|[x]| means that we generated enough trees for such a section.

We start with interpreting \(E_{0,0} = (k + 1) C_k\). From statistics above, we see that we should generate \(16\) trees. \((k + 1)\) suggests pointing to a virtual leaf. Let's do so.

\begin{lstlisting}
c.define_class(0)

c.define_section(0)

c.append_r_class_subtree_visitor(1,       # we define positive trees
                                          # i.e. that count as 1
    lambda kind, left, right:
        None if kind[0] is not None else  # we ignore all actual nodes
        [kind + ("*", )] + left + right   # for each virtual node we point it
)
\end{lstlisting}

\begin{lstlisting}
# define 0,0: (k + 1) * Ck []
=== Classes stats ===
[x]  0,0:      16 of      16 | (k + 1) * Ck              []
[ ]  1,0:       0 of     -10 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:       0 of     -12 | - 2 * (k + 1) * Ck        [s]
[ ]  2,0:       0 of      -4 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of       1 | (k) * Ck                  [ll]
[ ]  2,2:       0 of       6 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of       2 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of       2 | 2 * (2 * k + 1) * Ck      [aos]
[x]  3,1:       0 of       0 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of      -1 | - (2 * k + 1) * Ck        [lss]
[x]  4,0:       0 of       0 | k * Ck                    [llss]
=== Diff stats ===
0,0:     0    16
\end{lstlisting}

The framework informs us that we have generated all trees for section \(0,0\) for \(n = 3\). It also can provide us with the visualization of the trees we have generated. For example:

\includeinlinesvg{.19}{lambda__trees_00__4_base}%
\(\Rightarrow\)
\includeinlinesvg{.19}{lambda__trees_00__4}%
\includeinlinesvg{.19}{lambda__trees_00__5}%
\includeinlinesvg{.19}{lambda__trees_00__6}%
\includeinlinesvg{.19}{lambda__trees_00__7}%

If we take a look at more examples from class \(0\), we can start seeing some patterns:

\includeinlinesvg{.33}{lambda__trees_00__2}%
\includeinlinesvg{.33}{lambda__trees_00__3}%
\includeinlinesvg{.33}{lambda__trees_00__7}%

\includeinlinesvg{.33}{lambda__trees_00__4}%
\includeinlinesvg{.33}{lambda__trees_00__12}%
\includeinlinesvg{.33}{lambda__trees_00__13}%

\includeinlinesvg{.16}{lambda__trees_00__0}%
\includeinlinesvg{.16}{lambda__trees_00__1}%
\includeinlinesvg{.16}{lambda__trees_00__5}%
\includeinlinesvg{.16}{lambda__trees_00__6}%
\includeinlinesvg{.16}{lambda__trees_00__14}%
\includeinlinesvg{.16}{lambda__trees_00__15}%

\includeinlinesvg{.25}{lambda__trees_00__8}%
\includeinlinesvg{.25}{lambda__trees_00__9}%
\includeinlinesvg{.25}{lambda__trees_00__10}%
\includeinlinesvg{.25}{lambda__trees_00__11}%

The order may be a bit suggestive. Section \(1,0\) adds a single \(l\) node, whereas section \(1,1\) adds a single \(s\) node. It actually suggests how we can try to generate the first and second line of the trees above. The first one is simple. Let's add \(l\) node with pointed right virtual node to each actual node:

\begin{lstlisting}
c.define_class(1)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,                # negative node
    lambda kind, left, right:
        None if kind[0] is None else                # we ignore all virtual nodes
        ["l", kind] + left + right + [(None, "*")]  # for each actual node we add
                                                    # l node with right virtual
                                                    # node pointed as a parent
)
\end{lstlisting}

It creates following trees:

\includeinlinesvg{.24}{lambda__trees_100__0_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__0}%
\includeinlinesvg{.24}{lambda__trees_100__1_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__1}%

\includeinlinesvg{.24}{lambda__trees_100__2_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__2}%
\includeinlinesvg{.24}{lambda__trees_100__3_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__3}%

It addresses all cases from the first line, but also introduces an incorrect lambda tree in which \(s\) is the parent of \(l\), which can not happen. We will fix it with the section \(2,2\) generating positive trees, which introduces one \(l\) node and one \(s\) by extending the tree with \(2\) nodes where \(s\) is parent of \(l\).

Next, we can take care of the later cases of section \(0, 0\). It can be also expressed using sections \(1, 0\) and \(1, 1\):

\begin{lstlisting}
c.define_class(1)

c.define_section(0)

# old visitor
c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["l", kind] + left + right + [(None, "*")]
)

# new visitor
c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + [left[0] + ("*",)] + left[1:] + right + [None]
)

# new visitor
c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + left + [right[0] + ("*",)] + right[1:] + [None]
)

c.define_section(1)

# old visitor
c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)

# new visitor
c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + left + [right[0] + ("*",)] + right[1:]
)

# new visitor
c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + [left[0] + ("*",)] + left[1:] + right
)
\end{lstlisting}

Basically, for each virtual node not being root (i.e.\ having left or right parent), we point it and add \(l\) or \(s\) respectively above the parent.

\includeinlinesvg{.32}{lambda__trees_111__1_base}%
\(\Rightarrow\)
\includeinlinesvg{.32}{lambda__trees_101__0}%
\includeinlinesvg{.32}{lambda__trees_112__0}%

The last row can be generated using section \(2, 0\):

\begin{lstlisting}
c.define_class(2)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", (None, "*"), None, kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", None, (None, "*"), kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", (None, "*"), None]
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", None, (None, "*")]
)
\end{lstlisting}

For each actual vertex, we add \(a\) node as its left or right parent and add as a second child \(o\) node as its sibling. We then point to the left or right virtual child of the newly created \(o\) node.

\includeinlinesvg{.20}{lambda__trees_200__0_base}%
\(\Rightarrow\)
\includeinlinesvg{.20}{lambda__trees_200__0}%
\includeinlinesvg{.20}{lambda__trees_201__0}%
\includeinlinesvg{.20}{lambda__trees_202__0}%
\includeinlinesvg{.20}{lambda__trees_203__0}%

After such transformations, we get following statistics:

\begin{lstlisting}
=== Classes stats ===
[x]  0,0:      16 of      16 | (k + 1) * Ck              []
[x]  1,0:     -10 of     -10 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:      -9 of     -12 | - 2 * (k + 1) * Ck        [s]
[x]  2,0:      -4 of      -4 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of       1 | (k) * Ck                  [ll]
[ ]  2,2:       0 of       6 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of       2 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of       2 | 2 * (2 * k + 1) * Ck      [aos]
[x]  3,1:       0 of       0 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of      -1 | - (2 * k + 1) * Ck        [lss]
[x]  4,0:       0 of       0 | k * Ck                    [llss]
=== Diff stats ===
1,0:     4     0
1,1:     3     0
\end{lstlisting}

This construction works also for bigger \(N\):

\begin{lstlisting}
=== Classes stats ===
[x]  0,0:   39050 of   39050 | (k + 1) * Ck              []
[x]  1,0:  -23237 of  -23237 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:  -17799 of  -24460 | - 2 * (k + 1) * Ck        [s]
[x]  2,0:  -13728 of  -13728 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of    3432 | (k) * Ck                  [ll]
[ ]  2,2:       0 of   14586 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of    3861 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of    4620 | 2 * (2 * k + 1) * Ck      [aos]
[ ]  3,1:       0 of   -2156 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of   -2310 | - (2 * k + 1) * Ck        [lss]
[ ]  4,0:       0 of     342 | k * Ck                    [llss]
=== Diff stats ===
1,0:  7602     0
1,1:  5832     0
2,0:  2280     0
\end{lstlisting}

The process can then be repeated for each section. We have chosen lexicographical order (i.e.\ \(0,0\); \(1,0\); \(1,1\); \(2,0\); \(\ldots\)).

\subsection{Final result}%
\label{sub:final_result}

After multiple iterations, we managed to come up with following construction:

\begin{lstlisting}
c.define_class(0)

c.define_section(0)

c.append_r_class_subtree_visitor(1,
    lambda kind, left, right:
        None if kind[0] is not None else
        [kind + ("*", )] + left + right
)


c.define_class(1)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["l", kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + [left[0] + ("*",)] + left[1:] + right + [None]
)

c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + left + [right[0] + ("*",)] + right[1:] + [None]
)

c.define_section(1)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)

c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + left + [right[0] + ("*",)] + right[1:]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + [left[0] + ("*",)] + left[1:] + right
)


c.define_class(2)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", (None, "*"), None, kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", None, (None, "*"), kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", (None, "*"), None]
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", None, (None, "*")]
)

c.define_section(1)

c.append_r_class_subtree_visitor(1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["l", "l", kind] + left + right + [(None, "*"), None]
)

c.define_section(2)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", "s", (None, "*"), parent_kind] + left + right + [None]
)

c.append_r_class_subtree_visitor(1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["s", None, "l", kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", parent_kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", parent_kind] + [left[0] + ("*", )] + left[1:] + right + [None]
)

c.append_r_class_left_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", parent_kind] + left + [right[0] + ("*", )] + right[1:] + [None]
)


c.define_section(3)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "s", (None, "*"), parent_kind] + left + right
)


c.define_class(3)

c.define_section(0)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", "o", (None, "*"), None, parent_kind] + left + right
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", "o", None, (None, "*"), parent_kind] + left + right
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", parent_kind] + left + right + ["o", (None, "*"), None]
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", parent_kind] + left + right + ["o", None, (None, "*")]
)

c.define_section(1)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", "l", parent_kind] + left + right + [(None, "*"), None]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        ["s", None, "l", "l", parent_kind] + left + right + [(None, "*"), None]
)


c.define_section(2)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "s", None, "l", parent_kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", "s", (None, "*"), parent_kind] + left + right + [None]
)


c.define_class(4)

c.define_section(0)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "s", None, "l", "l", parent_kind] + left + right + [(None, "*"), None]
)
\end{lstlisting}

It resulted in final statistics:

\begin{lstlisting}
=== Classes stats ===
[x]  0,0:   39050 of   39050 | (k + 1) * Ck              []
[x]  1,0:  -23237 of  -23237 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:  -17799 of  -24460 | - 2 * (k + 1) * Ck        [s]
[x]  2,0:  -13728 of  -13728 | - (4 * k) * Ck            [ao]
[x]  2,1:    3432 of    3432 | (k) * Ck                  [ll]
[ ]  2,2:   10833 of   14586 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:    1770 of    3861 | (k + 1) * Ck              [ss]
[ ]  3,0:    2280 of    4620 | 2 * (2 * k + 1) * Ck      [aos]
[ ]  3,1:   -1648 of   -2156 | - (2 * k) * Ck            [lls]
[ ]  3,2:   -1140 of   -2310 | - (2 * k + 1) * Ck        [lss]
[ ]  4,0:     187 of     342 | k * Ck                    [llss]
=== Diff stats ===
\end{lstlisting}

As you can see, diff stats are empty, so we managed to generate expected trees on both sides of the equation.

You may also note that we did not generate all trees suggested by the recurrence. This is due to one cheat we used.

\subsection{The cheat}%
\label{sub:the_cheat}

You may remember our assumptions in section \ref{sub:the_framework} about the discrimination cases. We allowed ourselves to apply visitors only to one of the left and right children, which is not handled by our holonomic recurrence as the number of such vertices does not depend only on \(n\).

To fix this, one can for example add construction for section \(1, 0\) to generate all expected trees from it and then repeat the iteration in order to generate matching trees on the other side of the equation. We can see that we used \(2\) constructions visiting nodes with right parent and only one visiting node having left parent, so our missing construction should also visit nodes with left parent.

\begin{lstlisting}
c.define_class(1)

c.define_section(0)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)

c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + left + [right[0] + ("*",)] + right[1:]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + [left[0] + ("*",)] + left[1:] + right
)

# example missing construction
c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)
\end{lstlisting}

Please note that it is only an example of missing construction. It is just the simplest one we could think about, and in that case, a simple solution is most often the correct one.

\section{Further work}%
\label{sec:further_work}

First thing to be done, that comes to mind immediately, is to finish the construction eliminating the cheat mentioned in section \ref{sub:the_cheat}.

You may also note that we are operating on specific \(N\). The probability that we miss some corner case is low, but even if we check large \(N\) values, it is always present. The formal algebraic proof would make us sure that the construction works. We would prioritize finishing the construction first.

The framework also is not perfect. It highly depends on the operator's intuition. We believe that the solving process can be automated. The simplest method that comes to mind is simply creating heuristic rules that then will be used by the framework to guess at least partial solutions.

With the proper interpretation, it may be possible to create a sampling algorithm similar to Rémy's one for binary trees\cite{remy,note}. It would have to take under consideration that some trees are being removed by other classes, so the probabilities would have to be set carefully.

We believe that one day all of that will be done or proven to be impossible.

\clearpage

\begin{thebibliography}{9}
    \bibitem{zigzag}
    Maciej Bendkowski, Katarzyna Grygiel, Pierre Lescanne, Marek Zaionc,
    \textit{A natural counting of lambda terms},
    2016

    \bibitem{gfun}
    Bruno Salvy, Paul Zimmermann,
    \textit{GFUN : a maple package for the manipulation of generating and holonomic functions in one variable},
    [Research Report] RT-0143, INRIA. 1992, pp.14. ffinria-00070025f

    \bibitem{holotoolkit}
    Manuel Kauers,
    \textit{The Holonomic Toolkit},
    in: Carsten Schneider, Johannes Blümlein (eds) Computer Algebra in Quantum Field Theory. Texts \& Monographs in Symbolic Computation (A Series of the Research Institute for Symbolic Computation, Johannes Kepler University, Linz, Austria),
    Springer, Vienna,
    2013

    \bibitem{nonholo}
    Stefan Gerhold,
    \textit{Combinatorial sequences: Non-holonomicity and inequalities. Ph.D. thesis},
    RISC-Linz, Johannes Kepler Universitat Linz,
    2005

    \bibitem{complexity}
    Igor Pak,
    \textit{Complexity problems in enumerative combinatorics},
    2018

    \bibitem{binary}
    Jean-Luc Rémy,
    \textit{Un procédé itératif de dénombrement d’arbres binaires et son application à leur génération aléatoire}
    Informatique théorique, tome 19, no 2, 
    1985,
    p. 179-195

    \bibitem{motzkin}
    Serge Dulucq, Jean-Guy Penaud,
    \textit{Interprétation bijective d'une récurrence des nombres de Motzkin},
    Discrete Mathematics,
    Volume 256, Issue 3,
    2002,
    p. 671-676

    \bibitem{schroder}
    Dominique Foata, Doron Zeilberger,
    \textit{A Classic Proof of a Recurrence for a Very Classical Sequence}
    J. Comb., Ser. A, 80,
    1997, 380-384

    \bibitem{doron}
    Doron Zeilberger,
    \textit{e-mail conversation},
    2020

    % Non-cited

    \bibitem{remy}
    Laurent Alonso Alonso, Jean-Luc Rémy, and René Schott,
    \textit{A Linear-Time Algorithm for the Generation of Trees},
    Algorithmica 17,
    1997,
    p. 162-182

    \bibitem{note}
    Jarmo Siltaneva, Erkki Mäkinen,
    \textit{A Note on Rémy's Algorithm for Generating Random Binary Trees},
    Missouri Journal of Mathematical Sciences. 15. 103-109. 10.35834/2003/1502103,
    2003 

    \bibitem{bodini}
    Axel Bacher, Olivier Bodini, Alice Jacquot,
    Efficient random sampling of binary and unary-binary trees via holonomic equations,
    2014

    % Additional

    \bibitem{transformator}
    Bartłomiej Puget,
    \textit{Transformator framework},
    \url{https://github.com/Larhard/transformator},
    2021

\end{thebibliography}

\end{document}
