\documentclass[final]{article}

\usepackage{todonotes}
\setlength{\marginparwidth}{2.5cm}

\RequirePackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{ }
\DeclareUnicodeCharacter{25CF}{\(\n\)}

\RequirePackage{color}
\definecolor{ao(english)}{rgb}{0.0, 0.5, 0.0}
\definecolor{blue(pigment)}{rgb}{0.2, 0.2, 0.6}
\definecolor{egyptianblue}{rgb}{0.06, 0.2, 0.65}
\definecolor{lightgray}{gray}{0.60}

\RequirePackage{listings}
\lstset{
    basicstyle=\footnotesize\ttfamily,
    comment=[l]{\#},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{lightgray}\ttfamily,
    escapeinside={<@}{@>}
}

\RequirePackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    filecolor=black,
    urlcolor=black
}

\RequirePackage{geometry}
\RequirePackage{tabularx}
\RequirePackage{longtable}
\RequirePackage{graphicx}
\RequirePackage{svg}
\RequirePackage{float}

\svgpath{images/}

\RequirePackage[maxbibnames=99]{biblatex}
\addbibresource{bibliography.bib}

\RequirePackage{amsthm}
\RequirePackage{amsmath}
\RequirePackage{mathtools}
\RequirePackage{amsfonts}
\RequirePackage{soul}
\RequirePackage{xspace}
\RequirePackage{bussproofs}
\RequirePackage[customcolors]{hf-tikz}

\RequirePackage{tikz}
\RequirePackage{setspace}

\RequirePackage{multicol}
\RequirePackage{lipsum}
\RequirePackage{textpos}

\setlength{\parindent}{0pt}
\setlength{\parskip}{.7em}

\title{Combinatorial interpretations of holonomic recurrences}
\author{Bartłomiej Puget}

\date{\today}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsection]

\theoremstyle{definition}
\newtheorem{interpretation}{Interpretation}[subsection]

\theoremstyle{remark}
\newtheorem{example}{Example}[subsection]

\newcounter{highlightid}
\newcommand{\mhl}[1]{{\tikzmarkin[set fill color=red!30,set border color=red]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}

\newcommand{\mhlr}[1]{{\tikzmarkin[set fill color=red!30,set border color=red]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}
\newcommand{\mhlg}[1]{{\tikzmarkin[set fill color=green!30,set border color=green]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}
\newcommand{\mhlb}[1]{{\tikzmarkin[set fill color=blue!30,set border color=blue]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}

\newcommand{\ols}[1]{\mskip.5\thinmuskip\overline{\mskip-.5\thinmuskip {#1} \mskip-.5\thinmuskip}\mskip.5\thinmuskip} % overline short
\newcommand{\olsi}[1]{\,\overline{\!{#1}}} % overline short italic

\newcommand{\gf}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\enc}[1]{\ensuremath{\ols{#1}}}
\newcommand{\pointed}[1]{\ensuremath{{#1}^*}}
\newcommand{\weighted}[1]{\ensuremath{_{(#1)}}}
\newcommand{\size}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\LambdadB}{\ensuremath{\Lambda_{\text{dB}}}}

\DeclareMathOperator{\textiff}{\text{iff}}
\DeclareMathOperator{\N}{\mathbb{N}}
\DeclareMathOperator{\poly}{\mathbb{P}}
\DeclareMathOperator{\troot}{\text{root}}
\DeclareMathOperator{\tleft}{\text{left}}
\DeclareMathOperator{\tright}{\text{right}}
\DeclareMathOperator{\tLeft}{\text{Left}}
\DeclareMathOperator{\tRight}{\text{Right}}
\DeclareMathOperator{\tSub}{\text{Sub}}
\DeclareMathOperator{\tPre}{\text{Pre}}
\DeclareMathOperator{\tSuf}{\text{Suf}}
\DeclareMathOperator{\n}{\bullet}
\DeclareMathOperator{\no}{\o}

\newcommand{\includeinlinesvg}[2]{\begin{minipage}{#1\textwidth}\includesvg[width=\textwidth]{#2}\end{minipage}}
\newcommand{\includeinlinescaledsvg}[3]{\begin{minipage}{#1\textwidth}\begin{center}\includesvg[scale=#2]{#3}\end{center}\end{minipage}}

\begin{document}

\begin{titlepage}
	\begin{center}
	\textsc{\LARGE Jagiellonian University}

	\Large Faculty of Mathematics and Computer Science

	\Large Theoretical Computer Science

	\vfill

	\vspace{1cm}
	\hrulefill
	\vspace{0.5cm}

    \makeatletter
    \huge \textsc{\@title}
    \makeatother

	\vspace{0.2cm}
	\hrulefill

	\vspace{1cm}
    \makeatletter
	\textsc{\Large \@author}
    \makeatother

	\vspace{1cm}
    \normalsize

	Master Thesis\\
	Advisor: \textsc{Katarzyna Grygiel}

	\vfill

    \makeatletter
    \@date
    \makeatother
	\end{center}
\end{titlepage}

\section*{Abstract}%
\label{sec:abstract}

We analyze the problem of finding combinatorial interpretations of holonomic recurrences and show some techniques that were used to achieve known results.

We also try to find a~combinatorial interpretation of the holonomic recurrence for trees of lambda terms in the de Bruijn notation.

\clearpage

\tableofcontents
\clearpage

\section{Overview}%
\todo{generating functions}
\todo{holonomic recurrences}
\todo{publications about Motzkin, etc.}
\todo{Lambda terms}
\todo{zigzag free}

Every recursive structure can be described using a~generating function, which can be then transformed into a~holonomic recurrence. It allows us to quickly count objects of given structure with given size. At first glance, the recurrence seems to be closely related to the structure itself. It just seems like it should describe simple transformations resulting in constructing bigger objects from slightly smaller ones. In case of trees it could be for example adding vertices. However, there is no known method of interpreting it in the language of the combinatorial structures.

The initial inspiration for the thesis came from the publication \textit{A natural counting of lambda terms}~\cite{inspiration}, which shows bijections among seemingly different tree structures, which are lambda trees, black-white trees~\cite{blackwhite} and zigzag free trees\todo{cite}. They share the same holonomic recurrence, but there is no known immediate connection between the holonomic recurrence and the structures itself.

Throughout the thesis we try to accumulate known results and techniques that may help solving the problem of finding combinatorial interpretations. We also propose an~approach that helped us to find an~intermediate solution for the problem of finding combinatorial interpretation for holonomic recurrence of lambda trees in the unary de Bruijn notation. We use the de Bruijn indices in order to get rid of letter-based variable names. Unary notation allows us to connect size of the tree to the values of the de Bruijn indices.

In Section~\ref{sec:introduction} we establish notation nad introduce concepts that will be used throughout the thesis.

Next, in Section~\ref{sec:known_results}, we present known results, ie. binary trees, unary-binary trees and Schröder trees. They demonstrate combinatorial interpretations that reflect different approaches.

In Section~\ref{sec:approaches} we show approaches to the problem that helped to achieve the aforementioned results. All of them were tried in order to find the answer to the original problem of interpreting holonomic recurrence of trees of lambda terms in the unary de Bruijn notation. Unfortunately, none of them helped us enough to get the final result. Anyway, they are proven to be helpful when we are stuck, as most of them are able to divide problems into smaller parts and detect corner cases.

Section~\ref{sec:brutal_iterative_approach} presents our final approach to the original problem, i.e.~computer-aided iterative approach that allowed us to find the intermediate solution. We believe that it is possible to extend this idea in order to obtain the full solution, but we were not able to achieve that due to the limited time that was available to us.

Finally, in Section~\ref{sec:further_work}, we present our view on what can be done with the problem in the future. We believe that one day the problem will be fully solved and a~more generic approach to interpreting holonomic recurrences will emerge.

\clearpage

\section{Introduction}%
\label{sec:introduction}

\subsection{Notation}%
\label{sub:notation}

In order to make reading this thesis easier, let's fix some notation and make some assumptions. Any deviation from this will be clearly stated. If you have trouble guessing what some letter or word means, this should be your primary place to look for the answer.

e.g.~stands for Latin exempli gratia, which means \textit{for example}.

i.e.~stands for Latin id est, which means \textit{that is}.

\(\textiff\) means if and only if.

\(\poly\) is a~set of all polynomials.

\(n, m, i, j, k\) are implicitly assumed to be natural numbers.

\(f, g\) are implicitly assumed to be functions.

\(f^{(n)}\) is implicitly defined as \(n\)-th derivative of function \(f\).

\(V(T)\) is implicitly defined as a~set of nodes of the tree \(T\).

\(E(T)\) is implicitly defined as a~set of edges of the tree \(T\).

\(u, v\) are implicitly assumed to be nodes.

\(e\) is implicitly assumed to be an~edge.

\(\troot(T)\) is implicitly defined as a~root of tree \(T\).

\(\tleft(v)\) is implicitly defined as a~left child of node \(v\).

\(\tright(v)\) is implicitly defined as a~right child of node \(v\).

\(\tSub(v)\) is implicitly defined as a~whole subtree rooted with node \(v\).

\(\tLeft(v)\) is implicitly defined as a~left subtree of node \(v\).

\(\tRight(v)\) is implicitly defined as a~right subtree of node \(v\).

Sibling of node \(v\) is defined as node \(u\) having the same parent as \(v\).

Uncle of node \(v\) is defined as a~sibling of the parent of \(v\).

We say that node \(v\) is an~oneling \(\textiff\) \(v\) has no siblings. Note that the root is oneling even if it has no parent.

We say that node \(v\) is twinling \(\textiff\) \(v\) has at least one sibling.

Leaf is a~node which has no children.

\(\n\) is implicitly defined as a~default identifier of a~node.

\(\no\) is implicitly defined as an~identifier of a~non-existing node (e.g.~if \(v\) is a~leaf, \(\tleft(v) = \n\)).

Dashed edges 
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__dashed_edge}
\end{minipage}
depict edges that may or may not exist (e.g.~when we describe transformations and we do not care if the node is root or if it has children).

Green edges 
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__green_edge}
\end{minipage}
depict edges to \(\no\) nodes.

Virtual node is an~artificially defined node that does not affect the structure definition (e.g.~we can define virtual leafs that are children of actual leaves of the binary tree. Such virtual leaves are not included when counting the number of children of the node, so the actual leaves are still called leaves).

Actual node is a~node that is not virtual.

We say that node \(v\) is an~virtual-oneling \(\textiff\) \(v\) has no siblings being virtual nodes.

We say that node \(v\) is virtual-twinling \(\textiff\) \(v\) has at least one sibling being virtual node.

For a~binary tree, we say that node \(v\) is right (left) \(\textiff\) \(v\) is a~right (left) child of its parent.

For a~binary tree, we say that node \(v\) has a~right (left) parent \(u\) \(\textiff\) \(v\) is a~left (right) child of \(u\).

\(\pointed{v}\) is implicitly defined as a~pointed node \(v\). We can treat it as a~node with an~additional label \(\pointed{}\).

\(v\weighted{n}\) is implicitly defined as a~weighted node \(v\) with weight \(n\).

\(x_i\) is implicitly assumed to be an~\(i\)-th element of the sequence \(X\), where \(x\) can be any lower-case letter and \(X\) is upper-case \(x\).

Calligraphic \(\gf{X}\) is implicitly assumed to be a~generating function of the sequence \(X\) where \(X\) is any upper-case letter.

\(\size{X}\) is implicitly defined as the size of the object \(X\).

\subsection{Structurally recursive objects}%
\label{sub:structurally_recursive_objects}

We will be analyzing structures that can be expressed using recursive formulas. For example we can define a~full binary tree recursively as a~node having no children (i.e.~being a~leaf) or having exactly two subtrees being full binary trees. To express the disjoint alternative in the construction rule, we use \(+\). The reason will become obvious soon.

\begin{figure}[H]
    \begin{center}
        \begin{minipage}[t]{.2\textwidth}
            \begin{center}
                \(B\)\\
                \includesvg[scale=0.5]{binary__def_1}%
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.05\textwidth}
            \begin{center}
                \(=\)\\
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.2\textwidth}
            \begin{center}
                \(\text{leaf}\)\\
                \includesvg[scale=0.5]{binary__def_2}%
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.05\textwidth}
            \begin{center}
                \(+\)\\
            \end{center}
        \end{minipage}%
        \begin{minipage}[t]{.2\textwidth}
            \begin{center}
                \(B^2\)\\
                \includesvg[scale=0.5]{binary__def_3}%
            \end{center}
        \end{minipage}%
    \end{center}
    \caption{Binary tree recursive definition}
    \label{fig:binary_recursion}
\end{figure}

\subsection{Generating functions}%
\label{sub:generating_functions}
\todo{Source}
\todo{Make the section simpler}

Throughout the thesis we use ordinary generating functions to describe and count structures.

\begin{definition}
The ordinary generating function of sequence \(A = (a_i)_{i=0}^{\infty}\) is defined as a~formal power series:
\[\gf{A}(z) = \sum_{i=0}^{\infty} a_i z^i .\]
\end{definition}

Note that in order to compute the \(k\)-th element of the sequence, namely \(a_k\), we just need to find a~constant corresponding to indeterminate \(z^k\).

If we have a sequence counting some objects and a corresponding generating function, we say that this function counts the objects.

\begin{example}
    \label{ex:bin_gf}
    Let's consider recursive definition of binary trees shown in Figure~\ref{fig:binary_recursion}. We can create a~functional equation to count trees with exactly n internal nodes. To do so, we make internal nodes contribute to the generating function with \(z^1 = z\) and leaves with \(z^0 = 1\):

\[\gf{B}(z) = 1 + z\gf{B}^2(z).\]

In order to get some intuition on how it works underneath, let's take a~look at how we can find the number of full binary trees of size \(2\). We can expand the recurrence a~bit:

\[\begin{array}{rclr}
        \gf{B}(z) &=& 1 + z\gf{B}^2(z)\\
                  &=& 1 + z\bigg(1 + z\gf{B}^2(z)\bigg)\bigg(1 + z\gf{B}^2(z)\bigg)\\
                  &=& 1 + \mhl{z}\bigg(1 + \mhl{z}\Big(\mhl{1} + z\gf{B}^2(z)\Big)\Big(\mhl{1} + z\gf{B}^2(z)\Big)\bigg)\bigg(\mhl{1} + z\gf{B}^2(z)\bigg) &(*)\\
                  &=& 1 + z\bigg(1 + z\Big(1 + z\gf{B}^2(z)\Big)\Big(1 + z\gf{B}^2(z)\Big)\bigg)\bigg(1 + z\Big(1 + z\gf{B}^2(z)\Big)\Big(1 + z\gf{B}^2(z)\Big)\bigg)\\
                  &=& 1 + z + 2 z^2 + \bigg(2 \gf{B}^2(z) + \Big(1 + z \gf{B}^2(z)\Big)^2\bigg) z^3
\end{array}\]

It is enough, as the term \(\bigg(2 \gf{B}^2(z) + \Big(1 + z \gf{B}^2(z)\Big)^2\bigg) z^3\) will contribute only to \(z^k\) where \(k > 2\). Therefore, we can see that there are \(2\) trees with exactly \(2\) internal nodes, as multiplier next to \(z^2\) is \(2\).

To visualize even more, let's take a~look at the line marked with \((*)\). The highlighted terms describe following tree:

\begin{figure}[H]
    \begin{center}
        \includesvg[scale=.7]{intro__iilll}
    \end{center}
    \caption{Tree corresponding to highlighted terms in \((*)\)}
    \label{fig:tree_corresponding_to_mhl}
\end{figure}

\end{example}

There exist multiple well-known methods and tools that allow us to work with generating functions without the need of digging into details. The tool we will be using extensively in this work is the Maple package called GFUN~\cite{gfun}. If you want to learn more about algorithms used in the package, we strongly encourage reading the referenced article.

\subsection{Holonomic recurrences}%
\label{sub:holonomic_recurrences}
\todo{Extend the section}

Since most of the time we will be working with holonomic recurrences, let's introduce them.

\begin{definition}[\cite{holotoolkit}]
    \label{def:holo_1}
    An infinite sequence \(A = (a_i)_{i=0}^{\infty}\) is holonomic (aka. P-finite, P-recursive or D-recursive) \(\textiff\) there exists a~holonomic recurrence for it, i.e.

\[\exists_{r \in \N} \exists_{p_0, \ldots, p_r \in \poly} \forall_{n \in \N} \sum_{i=0}^r p_i(n)a_{n+i} = 0 .\]
\end{definition}

Note that the sum can only take a~finite number of subsequent elements of the sequence \(A\) into the relation.

\begin{example}
    The sequence \(a_n = \frac{5n - 3}{3n + 5}\) is holonomic, because it satisifies
    \[(3n + 5)(5n + 2) a_n - (5n - 3)(3n + 8) a_{n+1} = 0 .\]
\end{example}

\begin{example}
    Sequences \(a_n = \sqrt{n}\), \(b_n = n^n\) are \textbf{not} holonomic, i.e.~none of them satisfies a~linear recurrence equation with polynomial coefficients~\cite{nonholo}.
\end{example}

\begin{definition}[\cite{complexity}]
    \label{def:holo_2}
    Equivalently to Definition~\ref{def:holo_1}, \(A = (a_i)_{i=0}^{\infty}\) is holonomic \(\textiff\) there exists a~generating function in the following form:
    \[\sum_{i=0}^{r} p_i(z) \gf{A}^{(i)}(z) = b(z)\]
    for some fixed \(r \in \N\); \(b, p_0, \ldots, p_r \in \poly\) not all identical to zero.
\end{definition}

The equivalence of these two definitions assures us that if we find an~generating function equation describing the desired objects satisfying Definition~\ref{def:holo_2}, we will be able to find holonomic recurrence mentioned in Definition~\ref{def:holo_1}~\cite{complexity}.

\begin{example}
    \label{ex:gfun-rec}
    For generating function counting full binary trees defined in Example~\ref{ex:bin_gf}, i.e.:
    \[\gf{B}(z) = 1 + z\gf{B}^2(z)\]
    we can use GFUN~\cite{gfun} to immediately find a~holonomic recurrence of our interest:

    \begin{lstlisting}
> with(gfun):
> RootOf(B = B^2*z + 1, B);
             2
    RootOf(_Z  z - _Z + 1)

> algfuntoalgeq(%, B(z));
     2
    B  z - B + 1

> algeqtodiffeq(%, B(z));
                              2      /d      \
    1 + (-1 + 2 z) B(z) + (4 z  - z) |-- B(z)|
                                     \dz     /

> rec := diffeqtorec(%, B(z), B(n));
    rec := {(2 + 4 n) B(n) + (-2 - n) B(n + 1), B(0) = 1}
    \end{lstlisting}

    Our holonomic recurrence is then
    \[\left\{\begin{array}{rcl}
                b_0 &=& 1\\
                (2 + 4 n) b_n + (-2 - n) b_{n + 1} &=& 0
    \end{array}\right. .\]

    The most interesting part for us is the relation among the finite number of consecutive elements of the sequence.
\end{example}

\subsection{Combinatorial interpretations}%
\label{sub:combinatorial_interpretations}

Combinatorial interpretation is just a~fancy name for something you probably know and use. For example if you know the binomial coefficient \(\binom{n}{k}\), I bet it was introduced to you as something like: "let's assume you have \(n\) distinguishable balls. If you want to choose \(k\) from them, then you can do it in \(\binom{n}{k}\) ways" and now, whenever you see the term \(\binom{n}{k}\), you interpret it as the number of ways to choose \(k\) objects from the set of size \(n\). This is the combinatorial interpretation of the binomial coefficient.

Holonomic recurrences are very useful if we want to count objects of a~given size. Of course, size can be defined in more complex ways, e.g.~we may want to find the number of binary trees with \(n\) internal nodes having exactly \(m\) nodes being left child of its parent. Unfortunately, there is no commonly known method to find their intuitive interpretation in the world of the objects they describe.

In the thesis we try to gather methods and results that may be helpful for anyone trying to find such an~interpretation, as we believe that it may give better insight into the nature of the structure and make it easier to study the structure's properties.

\subsection{Pre-order notation}%
\label{sub:pre_order_notation}

In the thesis, if not stated otherwise, we will be working on rooted ordered unlabeled \(n\)-ary trees. To understand the terms, let's define them:
\begin{itemize}
    \item rooted tree is a~tree with single vertex marked as root. This allows us to define hierarchy of nodes using such terms as parent and child;
    \item ordered trees introduce order on children from the leftmost to the rightmost;
    \item unlabeled trees have nodes that are not distinguishable by their label. We will introduce soon kinds of nodes, but you shouldn't treat them as labels, but rather way to describe the structure of the node that is already present (e.g.~we can call node with just left child an~\(l\) node, but it is not its label. If the right child was added to the \(l\) node, it would not be an~\(l\) node anymore).
\end{itemize}
Additionally we allow that \(n\)-ary node has some of its children unset (e.g.~we can define a~binary node with just left child set, but not right one).

In order to make notation easier and unambiguous, we introduce pre-order notation of an~\(n\)-ary tree.

\begin{definition}
    For single vertex \(v\), the pre-order notation is defined as \(\enc{v}\).
\end{definition}

Here, \(\enc{v}\) is defined as follows:
\begin{itemize}
    \item if \(v\) is an~existing node, \(\enc{v} = \n\);
    \item if \(v\) is a~non-existing node (i.e.~we describe non-existing child of some node), \(\enc{v} = \no\).
\end{itemize}

\begin{definition}
    Pre-order notation of \(n\)-ary tree \(T\), namely \(\enc{T}\), is defined recursively as:
    \[\enc{T} = \enc{\troot(T)} \prod_{i=1}^{n} \enc{i\text{-th subtree of } \troot(T)}\]
    i.e.~catenation of the identifier of the root of the tree with encoded its subtrees from left to right.
\end{definition}

\begin{figure}[H]
    \centering
    \includesvg[scale=.7]{intro__oononnn}
    \caption{Tree described in the pre-order notation as: \(\n \n \no \n \no \no \no\).}
    \label{fig:oononnn}
\end{figure}

We use green edges 
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__green_edge}
\end{minipage}
to depict edges to \(\no\) nodes.

You can note that the encoding of a~given tree is unique. Unfortunately, not every sequence encodes proper tree.

We can also define prefixes and suffixes of \(T\) in relation to a~node \(v\).

\begin{definition}
    \(\tSub(v)\) is defined as a~whole subtree rooted with node \(v\).
\end{definition}

\begin{definition}
    Let \(v\) be a~node described using \(k\)-th symbol of \(\enc{T}\). Notation of the prefix of \(T\) in relation to \(v\), namely \(\enc{\tPre(T, v)}\), is defined as a~prefix of \enc{T} of size \(k - 1\).
\end{definition}

\begin{definition}
    Let \(n\) be the length of the sequence \(\enc{T}\). Notation of suffix of \(T\) in relation to \(v\), namely \(\enc{\tSuf(T, v)}\), is defined as a~suffix of \enc{T} of size \(n - \size{\enc{\tPre(T, v)}} - \size{\enc{\tSub(v)}}\).
\end{definition}

In other words, prefix of the tree \(T\) in relation to \(v\) describes a~part of the tree that appears before subtree rooted in \(v\) in pre-order notation. Suffix describes part of the tree that appears after it.

\begin{figure}[H]
    \centering
    \includesvg[scale=.7]{intro__presuf_custom}
    \caption{Visualization of prefixes, suffixes and subtrees}
    \label{fig:presuf}
\end{figure}

Throughout thesis we define some operations using this notation. Valid pre-order notation of \(n\)-ary tree (note that not all sequences are valid pre-order notations) can be easily translated back into a~tree. In order to do so, we just take first symbol of the notation and create the root accordingly. Then for each of the \(n\) children of the root, in sequence, we decode it recursively as if it was whole tree. Each such operation consumes some prefix of the notation. At the end we should be left with no symbols in the sequence.

As \(T\) and \(\enc{T}\) describe the same structures, notation of trees \(T\) and its encoding \(\enc{T}\) will be used interchangeably.

\section{Known results}%
\label{sec:known_results}
\todo{Add introduction}

\subsection{Binary trees}%
\label{sub:binary_trees}

Let's start with probably the most known interpretation, full binary trees~\cite{binary}.

We define the size of a~tree as the number of its internal nodes (i.e.~nodes that are not leaves). Our generating function is therefore a~solution of the following equation

\[\gf{B}(z) = 1 + z\gf{B}^2(z)\]

After a~quick transformation, we get the following holonomic recurrence:

\[\left\{\begin{array}{rcl}
            b_0 &=& 1\\
            (n + 2)b_{n + 1} &=& 2 (2n + 1)b_n
\end{array}\right.\]

This equation actually have \(2\) solutions, but we can eliminate one of them due to assumption that we are counting objects, i.e.~we are interested only in solutions that give us natural numbers.

Numbers defined as above are also known as Catalan numbers.

It is easy to see that a~tree of size \(n\) (i.e.~with \(n\) internal nodes) has \(n + 1\) leaves and therefore \(2n + 1\) nodes in total. Analogically the tree of size \(n + 1\) has \(n + 2\) leaves and \(2n + 3\) nodes in total. If you see some resemblance to our holonomic recurrence, you are perfectly right.

We are going to create a~bijection between the left and right side of the recurrence. We will be using the term \textit{bijective language} to talk about the recurrence using the objects it describes and their transformations.
\todo{rewrite}

\begin{interpretation}
Let's translate the recurrence to the bijective language.
\begin{itemize}
    \item \(b_n\) is simply the set of all full binary trees of size \(n\),
    \item \((n + 2) b_{n + 1}\) is the set of all full binary trees of size \(n + 1\) with one of the leaves pointed,
    \item \((2n + 1) b_{n}\) is the set of all full binary trees of size \(n\) with one of the nodes (either internal or a~leaf) pointed (i.e.~distinguished),
    \item \(2\) at the beginning of \(2 (2n + 1) b_{n}\) indicates that we will be using \(2\) copies of the set defined in the previous bullet.
\end{itemize}

At the moment the left side of the recurrence is related to trees of size \(n + 1\), the right, on the other hand, of size \(n\). Therefore, we need to apply some transformations on trees.

Let's define two local operations for tree \(T\) with a~single node \(v\) pointed: \(R_l(T, v)\) and \(R_r(T, v)\). The term \textit{local} means that the operation can operate on just some finite fragment of a~tree with predefined size (e.g.~node and its 2 children, but cannot traverse the whole tree).

\begin{definition}
    \(\enc{R_l(T, v)} = \enc{\tPre(T, v)} \n \pointed{\n} \no \no \enc{\tSub(v)} \enc{\tSuf(T, v)}\)
\end{definition}

\begin{figure}[H]
    \centering
    \begin{minipage}{.25\textwidth}\includesvg[scale=0.35]{binary__remy_base}\end{minipage}%
    \(\Rightarrow\)
    \begin{minipage}{.4\textwidth}\includesvg[scale=0.5]{binary__remy_left}\end{minipage}%
    \caption{Visualization of \(\enc{R_l(T, v)}\)}
    \label{fig:remy_left}
\end{figure}

\begin{definition}
    \(\enc{R_r(T, v)} = \enc{\tPre(T, v)} \n \enc{\tSub(v)} \pointed{\n} \no \no \enc{\tSuf(T, v)} \)
\end{definition}

\begin{figure}[H]
    \centering
    \begin{minipage}{.25\textwidth}\includesvg[scale=0.35]{binary__remy_base}\end{minipage}%
    \(\Rightarrow\)
    \begin{minipage}{.4\textwidth}\includesvg[scale=0.5]{binary__remy_right}\end{minipage}%
    \caption{Visualization of \(\enc{R_r(T, v)}\)}
    \label{fig:remy_right}
\end{figure}

We can now take the bijective interpretation of \((2n + 1) B(n)\), i.e.~trees of size \(n\) with a~single node pointed. For each of such trees, \(T\) we create new one by applying \(R_l\) and \(R_r\) to the pair \(T', v\), where \(T'\) is \(T\) with removed pointers and \(v\) is a~node that is pointed in \(T\). Therefore we generate \(2(2n + 1) B(n)\) trees of size \(n + 1\).
\todo{rewrite}

The only thing that's left for us to verify is if we generate all trees of size \(n + 1\) with pointed leaves. As from the recursion, we know that \(2 (2n + 1) B(n)\) is total number of trees with single leaf pointed, it is enough to check if we do not generate any duplicate using \(R_l\) and \(R_r\). It can happen in 2 ways:
\begin{enumerate}
    \item operation itself generates duplicates or
    \item 2 different operations generate the same tree.
\end{enumerate}

First case can also be split into 2 subcases. Without loss of generality we can analyze just one of the operations, let it be \(R_l\). The second case is symmetric.
\begin{itemize}
    \item for some nodes \(u \neq v\), \(R_l(T, u) = R_l(T, v)\). Let \(i_u, i_v\) be the indices of respectively \(\enc{u}\) and \(\enc{v}\) in \(\enc{T}\). Let \(\pointed{i}_u, \pointed{i}_v\) be the indices of pointed node respectively in \(\enc{R_l(T, u)}\) and \(\enc{R_l(T, v)}\). Due to the definition of \(R_l\), we get that \(\pointed{i}_u = i_u + 1\) and \(\pointed{i}_v = i_v + 1\), which implies that \(u = v\) what we assumed false.
    \item for some trees \(T \neq S\), \(R_l(T, u) = R_l(S, v)\). Let \(i_u, i_v\) be the indices of respectively \(\enc{u}\) in \(\enc{T}\) and \(\enc{v}\) in \(\enc{S}\). Let \(\pointed{i}_u, \pointed{i}_v\) be the indices of pointed node respectively in \(\enc{R_l(T, u)}\) and \(\enc{R_l(S, v)}\). If \(\pointed{i}_u \neq \pointed{i}_v\), this case is trivially false, so we can assume that \(\pointed{i}_u = \pointed{i}_v\). Therefore, again from the definition of \(R_l\), we have that \(i_u = i_v\). That implies that \(\enc{\tPre(T, u)} \enc{\tSub(u)} \enc{\tSuf(T, u)} = \enc{\tPre(S, v)} \enc{\tSub(v)} \enc{\tSuf(S, v)} \), which then sums up to \(\enc{T} = \enc{S}\), which we assumed false.
\end{itemize}

In the second case it is enough to notice that \(R_l\) generates trees with pointed nodes being a~left child, and \(R_r\) generates trees with pointed nodes being right child. That immediately provides us with the conclusion that we are generating no duplicates.

\qed
\end{interpretation}

\subsection{Unary-binary trees}%
\label{sub:unary_binary_trees}

Let's think, what would have changed if we introduce unary nodes to the binary case~\cite{motzkin}.

\begin{definition}
    \label{def:unary_binary_tree}
    An unary-binary tree is an~ordered tree in which any node can have either 0, 1 or 2 children.
\end{definition}

We do not allow nodes with gaps here, e.g. a~binary node with just one child or unary node with no children.

We will define size as number of edges. Note that a~tree having \(n\) edges has exactly \(n + 1\) nodes.

We can easily derive the generating function:

\[\gf{U}(z) = 1 + z\gf{U}(z) + z^2 \gf{U}^2(z)\]

And with a~bit of Maple magic~\cite{gfun}, we immediately get the following recurrence:

\[(n + 2)u_{n} = (2n + 1)u_{n - 1} + 3(n - 1)u_{n - 2}\]

\[\left\{\begin{array}{rcl}
            u_0 &=& 1\\
            u_1 &=& 1\\
            (n + 2)u_{n} &=& (2n + 1)u_{n - 1} + 3(n - 1)u_{n - 2}
\end{array}\right.\]

Definition~\ref{def:unary_binary_tree} is precise, but introduces a~new kind of node that we would have to take care of. We can avoid it by using a~trick to make unary-binary trees recall binary trees. We do not change the structure, just the notation.

\begin{definition}
    \label{def:unary_binary_2}
    A left-leaning binary tree is a~binary tree with the following constraint added: if a~node has a~right child, it also has a~left child. Of course a node with just a left child can appear in such tree.
\end{definition}

The bijection between unary-binary trees and left-leaning binary ones is very simple. We just represent unary nodes as nodes with just a~left child. The other cases translate immediately to themselves. Please note that this transformation preserves the size of the tree (i.e.~number of edges).

The next step is to make binary trees full. Let's define virtual leaves.

\begin{definition}
    Virtual node is an~artificially defined node that does not affect the structure definition (i.e.~they are not included when counting the number of children of the node).
\end{definition}

\begin{definition}
    Actual node is a~node that is not virtual.
\end{definition}

\begin{definition}
    A virtual leaf is a~virtual node added to the node in place of a~non-existing child.
\end{definition}

As we have added \(n + 2\) virtual nodes, we have added as many virtual edges.\todo{notes?}

\begin{figure}[H]
    \centering
    \includeinlinesvg{.2}{unary_binary__base}%
    \(\Rightarrow\)%
    \includeinlinesvg{.3}{unary_binary__full}
    \caption{Unary-binary tree to full-binary tree transformation}
    \label{fig:unary_binary_transformation}
\end{figure}

Please note that \(n + 2\) matches the multiplier of \(u_n\) in holonomic equation.

We will be using \(U(n)\) to describe sets of trees corresponding to \(u_n\) from the holonomic recurrence. The set \((n + 2) U(n)\) can be interpreted as trees of size \(n\) with single virtual leaf pointed.

\begin{definition}
    We say that node \(v\) is an~virtual-oneling \(\textiff\) \(v\) has no virtual siblings. Note that the root is an oneling even if it has no parent.
\end{definition}

\begin{definition}
    We say that node \(v\) is virtual-twinling \(\textiff\) \(v\) has at least one virtual sibling.
\end{definition}

\begin{definition}
    If \(u\) is parent of \(v\), we say that sibling of \(u\) is an~uncle of \(v\).
\end{definition}

\begin{interpretation}
To present the interpretation in bijective language, we will have to introduce several types of the nodes.

\begin{enumerate}
    \item Vro - virtual leaf being right virtual-oneling;
    \item Vrt - virtual leaf being right virtual-twinling. We will divide this case into:
        \begin{enumerate}
            \item VrtUrv - Vri which uncle is a~right virtual leaf;
            \item VrtUra - Vri which uncle is a~right actual node;
            \item VrtUla - Vri which uncle is a~left actual node.
        \end{enumerate}
    \item Vlt - virtual leaf left virtual-twinling. Note that from definition \ref{def:unary_binary_2}, left virtual leave cannot have a~sibling being an~actual node. We can divide also this case into:
        \begin{enumerate}
            \item VltUrv - Vlt which uncle is a~right virtual leaf;
            \item VltUra - Vlt which uncle is a~right actual node;
            \item VltUla - Vlt which uncle is a~left actual node;
        \end{enumerate}
    \item A - Actual node.
\end{enumerate}

Note that it covers all possible cases of nodes and all the cases are mutually disjoint. There is no such thing as VrtUlv, VltUlv nor Vlo due to Definition~\ref{def:unary_binary_2}.

All we need to show are transformations from the smaller cases, i.e.~pointed trees from \(U(n-1)\) and \(U(n-2)\) to \(U(n)\).

Let's start from \(U(n-1)\). Its multiplier is \(2n + 1\). It suggests that we can point to any node, as in a~tree having \(n - 1\) actual edges, we have \(n\) actual and \(n + 1\) virtual nodes.

In the case of \(U(n-2)\), the multiplier is \(3(n-1)\), which suggests that we should perform \(3\) distinct types of transformations on the trees with a~pointed actual node.

In the table below we show transformations that are applied to trees from \(U(n-1)\) and \(U(n-2)\) in order to achieve trees from \(U(n)\). We mark pointed node with \(\pointed{}\). You can find the case name in the bottom left corners of cells.

\begin{center}
    \begin{longtable}{| c | c | c | c |}
        \hline

        \(U(n-2)\) &
        \(U(n-1)\) &
               &
        \(U(n)\)\\
        \hline

        &
        A \includesvg[scale=0.4]{unary_binary__1si} &
        \(\Rightarrow\)&
        Vro \includesvg[scale=0.4]{unary_binary__0fid} \\
        \hline

        &
        Vlt \includesvg[scale=0.4]{unary_binary__1fjg} &
        \(\Rightarrow\)&
        VrtUrv \includesvg[scale=0.4]{unary_binary__0fjdOgf} \\
        \hline

        A \includesvg[scale=0.4]{unary_binary__2i} &
        &
        \(\Rightarrow\)&
        VrtUra \includesvg[scale=0.4]{unary_binary__0fjdOdi} \\
        \hline

        &
        Vro \includesvg[scale=0.4]{unary_binary__1fid} &
        \(\Rightarrow\)&
        VrtUla \includesvg[scale=0.4]{unary_binary__0fjdOgi} \\
        \hline

        &
        Vrt \includesvg[scale=0.4]{unary_binary__1fjd} &
        \(\Rightarrow\)&
        VltUrv \includesvg[scale=0.4]{unary_binary__0fjgOdf} \\
        \hline

        A \includesvg[scale=0.4]{unary_binary__2i} &
        &
        \(\Rightarrow\)&
        VltUra \includesvg[scale=0.4]{unary_binary__0fjgOdi} \\
        \hline

        A \includesvg[scale=0.4]{unary_binary__2i} &
        &
        \(\Rightarrow\)&
        VltUla \includesvg[scale=0.4]{unary_binary__0fjgOgi} \\
        \hline
    \end{longtable}
\end{center}


As you can see, we have satisfied all of the cases of trees from \(U(n-2)\), \(U(n-1)\) and \(U(n)\) with no repetitions, which concludes the construction.

\qed
\end{interpretation}

\subsection{Schröder trees}%
\label{sub:schröder_trees}

The next case we will show is the case of Schröder trees~\cite{schroder}.

\begin{definition}
    \label{def:schroder_tree}
    A Schröder tree is a~tree with no unary nodes. Empty children are not allowed (e.g.~binary node with just one child).
\end{definition}

Simply speaking, nodes can have zero or strictly more than one child.

\begin{figure}[H]
    \centering
    \includesvg[scale=0.4]{schroder__example_1}
    \includesvg[scale=0.4]{schroder__example_2}
    \includesvg[scale=0.4]{schroder__example_3}
    \includesvg[scale=0.4]{schroder__example_4}
    \(\ldots\)
    \caption{Possible cases of Schröder tree nodes}
    \label{fig:schroder_trees}
\end{figure}

This definition is precise, but is difficult to implement as a~structural recursion. Let's define binary structure that will allow us to encode all Schröder trees.

\begin{definition}
    \label{def:well_weighted}
    A well-weighted full binary tree is a~weighted tree such that:
    \begin{itemize}
        \item leaves are unweighted;
        \item internal nodes can have weight either \(1\) or \(2\);
        \item if an~internal node has weight 2, then its right child is not a~leaf.
    \end{itemize}
\end{definition}

Let's represent node \(v\) with a~weight \(n\) as \(v\weighted{n}\).

We can easily define the bijection \(\Phi\) between models from Definition~\ref{def:schroder_tree} and~\ref{def:well_weighted} using pre-order notation:
\[\Phi(T) = \left\{\begin{array}{lcl}
            \n \no \no &:& T = \n \no \no \\
            \n\weighted{1}\; T_1\; T_2 &:& T = \n\; T_1\; T_2\\
            \n\weighted{2}\; T_1\; \Phi(\n\; T_2 \ldots T_n) &:& T = \n\; T_1\; T_2 \ldots T_n
\end{array}\right.\]
\todo{image}

Let's define the size of the tree as a~number of its leaves. As leaves are translated to leaves and internal nodes to internal nodes, the bijection \(\Phi\) is size-preserving.

The generating function equation is then:

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}_1(z) + \gf{T}_2(z) + z\\
            \gf{T}_1(z) &=& \gf{T}^2(z)\\
            \gf{T}_2(z) &=& \gf{T}(z)(\gf{T}_1(z) + \gf{T}_2(z))
\end{array}\right.\]

\(\gf{T}_1\) and \(\gf{T}_1\) are generating functions of trees rooted in nodes of weight \(1\) and \(2\) respectively. \(\gf{T}\) is a generating function for the whole well-weighted full binary tree.

To be able to use Maple to generate the corresponding recurrence, we need to transform this system of equations to a~single one. We can eliminate \(\gf{T}_1(z)\) first.

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}^2(z) + \gf{T}_2(z) + z\\
            \gf{T}_2(z) &=& \gf{T}(z)(\gf{T}^2(z) + \gf{T}_2(z))
\end{array}\right.\]

\[\left\{\begin{array}{rcl}
            \gf{T}(z) &=& \gf{T}^2(z) + \gf{T}_2(z) + z\\
            \gf{T}_2(z)(1 - \gf{T}(z)) &=& \gf{T}^3(z)
\end{array}\right.\]

As we cannot use division to get \(\gf{T}_2(z)\), let's multiply the first equation by \(1 - \gf{T}(z)\).

\[\gf{T}(z)(1 - \gf{T}(z)) = \gf{T}^2(z)(1 - \gf{T}(z)) + \gf{T}^3(z) + z(1 - \gf{T}(z))\]

It can be actually used now to generate the holonomic recurrence.

\begin{lstlisting}
> with(gfun):
> RootOf(T*(1 - T) = T^2*(1 - T) + T^3 + z*(1 - T),  T);
               2
    RootOf(2 _Z  + (-z - 1) _Z + z)

> algfuntoalgeq(%, T(z));
       2
    2 T  + (-z - 1) T + z

> algeqtodiffeq(%, T(z));
                               2            /d      \                   2
    {z - 1 + (-z + 3) T(z) + (z  - 6 z + 1) |-- T(z)|, T(0) = RootOf(2 _Z  - _Z)}
                                            \dz     /

> diffeqtorec(%, T(z), T(n));

    {(n - 1) T(n) + (-3 - 6 n) T(n + 1) + (n + 2) T(n + 2), ...}

> subs(n = n - 1, %);

    {(-2 + n) T(n - 1) + (3 - 6 n) T(n) + (n + 1) T(n + 1), ...}
\end{lstlisting}

We can also move \(t_n\) to the other side, i.e.:

\[\left\{\begin{array}{rcl}
            t_1 &=& 1\\
            t_2 &=& 1\\
            3 (2 n - 1) t_n &=& (n - 2) t_{n - 1} + (n + 1) t_{n + 1}
\end{array}\right.\]

This may seem counterintuitive, as by default we want to describe how to generate larger cases from the smaller ones, but it will make the interpretation simpler.

Let's translate the recurrence to the bijective language then.
\begin{itemize}
    \item \((2 n - 1) T(n)\) describes well-weighted binary trees of size \(n\) (i.e.~with \(n\) leaves) with some node pointed (internal or leaf),
    \item \((n + 1) T(n + 1)\) describes well-weighted binary trees of size \(n + 1\) with some leaf pointed,
    \item \((n - 2) T(n - 1)\) describes well-weighted binary trees of size \(n - 1\) with some internal node pointed.
\end{itemize}

We will show the bijection between two sides of the recursion. We will transform each tree from \((2 n - 1) T(n)\) in three ways in order to achieve all trees from \((n + 1) T(n + 1)\). We will get some extra ones which are not well-weighted, but we will deal with them in a~minute.

Let's define three transformations, \(L_1\), \(L_2\), and \(R_1\) that transform tree with a~pointed node \(s\) into bigger tree, as follows. We use dashed edges 
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__dashed_edge}
\end{minipage}
to depict edges that may or may not exist (i.e.~when the node can have parent or child, but it does not have to). Whenever we use solid edge, we expect this edge to actually exist.

\begin{center}
    \includeinlinescaledsvg{.16}{.5}{schroder__lr_base}%
    \(\xRightarrow{L_1}\)%
    \includeinlinescaledsvg{.16}{.5}{schroder__l1}%
    \hspace{.1\textwidth}%
    \includeinlinescaledsvg{.16}{.5}{schroder__lr_base}%
    \(\xRightarrow{L_2}\)%
    \includeinlinescaledsvg{.16}{.5}{schroder__l2}%

    \includeinlinescaledsvg{.16}{.5}{schroder__lr_base}%
    \(\xRightarrow{R_1}\)%
    \includeinlinescaledsvg{.16}{.5}{schroder__r1}%
\end{center}

You can see that trees generated by \(L_1\) and \(R_1\) are always well-weighted. The problem appears when applying \(L_2\) when \(s\) is a~leaf.

When \(s\) is a~leaf, we will look at its parent. It can fall into one of following cases, where \(t'\) can be any tree and \(t''\) cannot be a~leaf.

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.5]{schroder__case_a}\\
            Case 1.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.5]{schroder__case_b}\\
            Case 2.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.5]{schroder__case_c}\\
            Case 3.
        \end{center}
    \end{minipage}%
\end{center}

When applying \(L_2\) we achieve following cases respectively:

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_a_l}\\
            Case 1.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_b_l}\\
            Case 2.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_c_l}\\
            Case 3.
        \end{center}
    \end{minipage}%
\end{center}

In case 1.~and 2.~we can just swap the labels as follows:

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_a_l_fixed}\\
            Case 1.
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_b_l_fixed}\\
            Case 2.
        \end{center}
    \end{minipage}%
\end{center}

It is easy to show that it constructs a bijection between \((n + 1) T(n + 1)\) and subset of \((2 n - 1) T(n)\) with \(L_1\), \(L_2\) and \(R_1\) applied, not falling into case 3. We will show that in a~moment.

To achieve trees from \((n - 2) T(n - 1)\), we can simply take trees from case 3.~and replace whole subtree with subtree of \(t''\) with its root pointed. In this way, we will lose \(2\) leaves and obtain each tree from \((n - 2) T(n - 1)\):

\begin{center}
    \begin{minipage}[t]{.3\textwidth}
        \begin{center}
            \includesvg[scale=0.45]{schroder__case_c_l_fixed}\\
            Case 3.
        \end{center}
    \end{minipage}%
\end{center}

To see the bijection, we can just draw all possible cases:

\begin{center}
    \begin{longtable}{| c | c | c | c | c |}
        \hline
        &
        \(\Rightarrow\)&
        \(R_1\) &
        \(L_1\) &
        \(L_2\) \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__21} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__23} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__22} &
        \begin{minipage}{.23\textwidth}
            \begin{center}
                \includeinlinescaledsvg{1}{.35}{schroder__proof__24}
                \(\Downarrow\)
                \includeinlinescaledsvg{1}{.35}{schroder__proof__24b}
            \end{center}
        \end{minipage}
        \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__11} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__13} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__12} &
        \begin{minipage}{.23\textwidth}
            \begin{center}
                \includeinlinescaledsvg{1}{.35}{schroder__proof__14}
                \(\Downarrow\)
                \includeinlinescaledsvg{1}{.35}{schroder__proof__14b}
            \end{center}
        \end{minipage}
        \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__31} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__33} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__32} &
        \begin{minipage}{.23\textwidth}
            \begin{center}
                \includeinlinescaledsvg{1}{.35}{schroder__proof__34}
                \(\Downarrow\)
                \includeinlinescaledsvg{1}{.35}{schroder__proof__34b}
            \end{center}
        \end{minipage}
        \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__51} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__53} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__52} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__54} \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__41} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__43} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__42} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__44} \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__61} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__63} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__62} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__64} \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__71} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__73} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__72} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__74} \\
        \hline

        \includeinlinescaledsvg{.23}{.35}{schroder__proof__81} &
        \(\Rightarrow\)&
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__83} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__82} &
        \includeinlinescaledsvg{.23}{.35}{schroder__proof__84} \\
        \hline

    \end{longtable}
\end{center}

In the left column you can see all possibilities of selecting \(s\) from a~tree of size \(n\). In \(R_1\), \(L_1\) and \(L_2\) columns we show how they are then transformed. It covers all possible cases of selecting leaf from a~tree of size \(n + 1\) and selecting an~internal node from a~tree of size \(n - 1\).

\section{Approaches}%
\label{sec:approaches}

As you could see in the examples above, most of the solutions are based on the simple analysis of the number of leaves, internal nodes and some of their special types. In this section, we will gather some methods that may be helpful when trying to analyze the problem of interpreting combinatorially some holonomic recurrences.

\subsection{Defining the size carefully}%
\label{sub:defining_the_size_carefully}

First thing to be done is to define the size carefully. We have a few standard choices for specifying the size of trees:
\begin{itemize}
    \item counting all existing nodes,
    \item counting internal nodes,
    \item counting leaves,
    \item counting virtual leaves (i.e.~virtual nodes being children of actual leaves),
    \item counting edges.
\end{itemize}

It may seem counterintuitive at first that this changes anything crucial, but the definition changes the shape of the holonomic recurrence. Sometimes changing the definition can drastically reduce the number of cases we have to consider.

There are two most common symptoms indicating that we may want to choose a different method of counting the size:
\begin{itemize}
    \item we get empty classes of objects, e.g.~if we analyze the problem of full binary trees and define the size as the number of all existing nodes, we cannot generate a tree of even size, therefore every second class is empty;
    \item we want to join trees using a newly created node, which will become the root of the new object and our equations are getting complicated. For example if we define the size as the number of internal nodes, such catenation creates a~tree of size being the sum of sizes of the components increased by \(1\). This \(+1\) can drastically clutter the holonomic recurrence. If we had defined the size as the number of leaves, the size of the new object would be just a~simple sum of the sizes of the smaller trees.
\end{itemize}

\subsection{Tree binarization}%
\label{sub:tree_binarization}

If we describe some structure we may be tempted to use multiple kinds of nodes, e.g.~unary and binary nodes. Having multiple kinds of nodes may cause problems, both in creating holonomic recurrence and finding the interpretation, as we have to keep track of how they can transform.

As the most common trees are binary ones, it may be worth an~effort to find some structure based on binary trees that can represent the original structure (see Section~\ref{sub:unary_binary_trees}).

\subsection{Custom weights assignment}%
\label{sub:weights_variablization}

Most of the time we are operating on trees with some nodes of weight \(0\) and some of weight \(1\). We may as well try to make them variable or assign some other values (e.g.~small prime numbers).

\todo{rewrite to unary-binary}
In Section~\ref{sub:lambda_terms} we will define trees of lambda terms. If we would assign following weights to nodes:

\[\begin{array}{rcl}
        a~&:& 7\\
        l &:& 5\\
        s &:& 3\\
        o &:& 2\\
\end{array}\]

we would get significantly smaller classes

\begin{longtable}{| c | c |}
    \hline

    Size & Trees
    \\\hline
    
    2 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_002_000000}
    \end{minipage}
    \\\hline

    5 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_005_000000}
    \end{minipage}
    \\\hline

    7 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_007_000000}
    \end{minipage}
    \\\hline

    8 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_008_000000}
    \end{minipage}
    \\\hline

    10 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_010_000000}
    \end{minipage}
    \\\hline

    11 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_011_000000}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_011_000001}
    \end{minipage}
    \\\hline

    12 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_012_000000}
    \end{minipage}
    \\\hline

    14 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000000}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000001}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000002}
    \end{minipage}
    \\\hline

    15 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_015_000000}
    \end{minipage}
    \\\hline

    16 &
    \begin{minipage}{.9\textwidth}\centering
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000000}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000001}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000002}
    \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000003}
    \end{minipage}
    \\\hline

    % 17 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000004}
    % \end{minipage}
    % \\\hline

    % 18 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_018_000000}
    % \end{minipage}
    % \\\hline

    % 19 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000006}
    % \end{minipage}
    % \\\hline

    % 20 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000007}
    % \end{minipage}
    % \\\hline

    % 21 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000006}
    % \end{minipage}
    % \\\hline

    % 22 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000007}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000008}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000009}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000010}
    % \end{minipage}
    % \\\hline

    % 23 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000007}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000008}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000009}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000010}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000011}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000012}
    % \end{minipage}
    % \\\hline

    % 24 &
    % \begin{minipage}{.9\textwidth}\centering
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000000}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000001}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000002}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000003}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000004}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000005}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000006}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000007}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000008}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000009}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000010}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000011}
    % \includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000012}
    % \end{minipage}
    % \\\hline
\end{longtable}

This method gives us some suggestion which kind of nodes are modified in the operation

Another benefit of this method is decreasing the cardinalities of sets of objects of a given size, so we have less objects to look at.

Unfortunately, decreasing the cardinalities of the classes increases the number of sets we need to analyze to get a~full interpretation.

\subsection{Inductive translation}%
\label{sub:inductive_translation}

Another method that may help us finding the interpretation is inductive translation~\cite{doron}. The method is based on the idea that most of the time there is an~easy way to find some natural recurrence (not necessarily holonomic) that has simple interpretation in bijective language.

In the case of binary trees with size defined as the number of leaves, we can define 2 recurrences:

\[\text{Holonomic recurrence} : n b_{n} = 2 (2n - 3) b_{n - 1}\]
\[\text{Non-linear recurrence} : b_{n} = \sum_{i=1}^{n - 1} b_{i} b_{n - i}\]

The non-linear one has a~very simple interpretation. We can take two smaller trees and join them using a newly created common root.

We can multiply both sides of non-linear recurrence by \(n\) and break up \(n = i + (n - i)\) to get two similar sums

\[n b_{n} = \sum_{i=1}^{n - 1} i b_{i} b_{n - i} + \sum_{i=1}^{n - 1} (n - i) b_{n - i} b_{i}\]

Using our inductive hypothesis, i.e.~holonomic recurrence and moving problematic boundary cases out from the sums (in this case \(b_{1}\) needs to be analyzed separately, as we did not define binary trees with no leaves), we can get the right side to use \(b_{n - 1}\) and prove that the holonomic recurrence using non-linear one. The only part that is left is to translate this inductive proof to the bijective language, which in such a~simple case as binary trees is quite simple, especially if one has seen the solution once.

The method itself has proven to be helpful in order to divide the problem into smaller parts and find some corner cases. Unfortunately, it does not give any immediate interpretation for applying the inductive step.
\todo{fill the gaps}
\todo{add reconstruction images}

\section{Brutal iterative approach}%
\label{sec:brutal_iterative_approach}

If all manual methods have failed and the problem is still too complex to interpret it by hand, a~computer comes in handy.

As our inspiration and main field of interest is an analysis of trees of lambda terms in unary de Bruijn notation, we will introduce them and use them as an~example to describe the method.

\subsection{Lambda terms}%
\label{sub:lambda_terms}

\todo{add story}
Let a countable set of variables be given.

\begin{definition}
    Set of lambda terms \(\Lambda\) is defined recursively:
    \begin{itemize}
        \item if \(x\) is a~variable, then \(x \in \Lambda\)
        \item if \(M, N \in \Lambda\), then \((M N) \in \Lambda\) (it can be interpreted as an application of function \(M\) to an~argument \(N\))
        \item if \(x\) is a~variable and \(M \in \Lambda\), then \((\lambda x . M) \in \Lambda\) (it can be interpreted as an~abstraction, i.e.~creating a~function with an~argument \(x\) and binding each occurrence of \(x\) in \(M\) to this argument. We say that variable \(x\) is abstracted by this \(lambda\)-abstraction)
    \end{itemize}
\end{definition}

\todo{introduce trees}
The definition above is quite popular, but introduces several problems. One of them is a~problem of a potential collision of lambda-abstracted variables and difficulty of finding to which lambda abstraction the variable is bound (or is it even a~free variable, i.e.~not bound). To address that, we can use de Bruijn indices.

\begin{definition}
    Set of lambda terms \(\LambdadB\) is defined recursively:
    \begin{itemize}
        \item if \(n \in \N\), then \(n \in \LambdadB\) (\(n\) is a~variable bound to lambda abstraction \(n\) levels above)
        \item if \(M, N \in \LambdadB\), then \((M N) \in \LambdadB\) (application)
        \item if \(M \in \LambdadB\), then \((\lambda M) \in \LambdadB\) (abstraction)
    \end{itemize}
\end{definition}

As you can see, we managed to eliminate name-based variables. We can also easily check if a~given variable is bound by checking its depth.

\begin{example}
    \(\lambda x . \lambda y . x\) is equivalent to \(\lambda \lambda 1\)
\end{example}

\begin{example}
    \(\lambda x . (\lambda y . x) (\lambda y . y)\) is equivalent to \(\lambda (\lambda 1) (\lambda 0)\)
\end{example}

It also allows us to define tree representation of the terms from \(\LambdadB\).
\todo{introduce unary notation; correlation between n and the size}

\begin{definition}
    Translation from lambda terms in de Bruijn notation to binary trees \(\Phi\) is defined as follows:
    \begin{itemize}
        \item \(\Phi(0) = \n\; \no\; \no\)
        \item \(\Phi(n) = \n\; \no\; \Phi(n - 1)\)
        \item \(\Phi(\lambda M) = \n\; \Phi(M)\; \no\)
        \item \(\Phi(M N) = \n\; \Phi(M)\; \Phi(N)\)
    \end{itemize}
\end{definition}

\todo{add note about injectiveness}
\todo{add image}
To simplify the interpretation, we can introduce several kinds of the nodes: \(o\), \(s\), \(l\) and \(a\). They do not change the structure, but make the reading a~bit easier:

\begin{definition}
    \(o\) is a~leaf.
\end{definition}

\begin{definition}
    \(s\) is a~node with only a right child.
\end{definition}

\begin{definition}
    \(l\) is a~node with only a left child.
\end{definition}

\begin{definition}
    \(a\) is a~node with both children.
\end{definition}

This leads to the following interpretation of \(\Phi\):

\begin{itemize}
    \item \(\Phi(0) = o\; \no\; \no\)
    \item \(\Phi(n) = s\; \no\; \Phi(n - 1)\)
    \item \(\Phi(\lambda M) = l\; \Phi(M)\; \no\)
    \item \(\Phi(M N) = a\; \Phi(M)\; \Phi(N)\)
\end{itemize}

You cannote that not every binary tree represents a~valid term.

\begin{example}
    \(\n\; \no\; \n\; \n\; \no\; \no\; \no\) does represent a~valid tree, but not a~valid lambda term.

To see that, we can take a~look at this tree with our node kinds used:

\todo{add image}
\[s\; \no\; l\; o\; \no\; \no\; \no\]

Here \(s\) represents the successor which can be applied only to \(n \in \N\), but is applied to the lambda-abstracted term.
\end{example}

\subsection{Enhanced holonomic recurrence}%
\label{sub:enhanced_holonomic_reccurence}

As we have our structure defined, let's create a generating function that will keep track of more than just the number of nodes, but also counts the number of each kind of node in the tree. The generating function \(\gf{T}(z, o, l, a, s)\) will be parameterized then using the following arguments:
\begin{itemize}
    \item \(z\) marking total number of virtual leaves
    \item \(o\) marking number of variable nodes
    \item \(l\) marking number of lambda abstraction nodes
    \item \(a\) marking number of application nodes
    \item \(s\) marking number of successors of variable nodes
\end{itemize}

In order to make the image cleaner, we will drop the arguments of generating functions, i.e.~\(\gf{T} := \gf{T}(z, o, l, a, s)\).


\begin{center}
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(\gf{T}\)\\
            \includesvg[scale=0.5]{lambda__def__1}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(=\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z a~\gf{T}^2\)\\
            \includesvg[scale=0.5]{lambda__def__2}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(+\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z l \gf{T}\)\\
            \includesvg[scale=0.5]{lambda__def__3}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(+\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(\gf{S}\)\\
            \includesvg[scale=0.5]{lambda__def__4}%
        \end{center}
    \end{minipage}%
\end{center}

where \(V\) represents part of the tree being variable (i.e.~\(o\) node, potentially with some \(s\) successor nodes applied):

\begin{center}
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(\gf{V}\)\\
            \includesvg[scale=0.5]{lambda__def__5}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(=\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z s \gf{V}\)\\
            \includesvg[scale=0.5]{lambda__def__4}%
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.05\textwidth}
        \begin{center}
            \(+\)\\
        \end{center}
    \end{minipage}%
    \begin{minipage}[t]{.2\textwidth}
        \begin{center}
            \(z o\)\\
            \includesvg[scale=0.5]{lambda__def__6}%
        \end{center}
    \end{minipage}%
\end{center}

After solving the equation for \(\gf{V}\), we get:
\[\gf{T} = z a~\gf{T}^2 + z l \gf{T} + \frac{z o}{1 - z s}\]

If we treat \(z\) as the only variable and make \(o\), \(l\), \(a\), and \(s\) constants, we can use a~little bit of Maple magic~\cite{gfun} to achieve the following holonomic recurrence.

\[\begin{array}{rl}
        0 =& (n - 4) l^2 s^2 t_{n - 4}\\
        +& ((4 n - 10) a o s - (2 n - 6) l^2 s - (2 n - 5) l s^2) t_{n - 3}\\
        +& ((-4 n + 8) a o + (n - 2) l^2 + (4 n - 6) l s + (n - 1) s^2) t_{n - 2}\\
        +& ((-2 n + 1) l - 2 n s) t_{n - 1}\\
        +& (n + 1) t_{n}
\end{array} .\]

Terms \(o\), \(l\), \(a\), and \(s\) appearing in the holonomic recurrence can be interpreted as list of kinds of nodes we need to use to extend smaller tree into bigger one.

\begin{example}
    Let's consider one of the summands, \((2n - 5) l s^2 t_{n - 3}\). We can interpret it as extending trees of size \((n - 3)\). In total we want to have \((2n - 5) t_{n - 3}\) of them and each of them should have some node pointed (we allow duplicates). To extend the tree we need to use exactly one \(l\) node and two \(s\) nodes.
\end{example}

If we forget about kinds of nodes, we get following recurrence:

\[\begin{array}{rl}
        0 =& (n - 4) t_{n - 4}\\
        +& t_{n - 3}\\
        +& (2 n - 1) t_{n - 2}\\
        +& (-4 n + 1) t_{n - 1}\\
        +& (1 + n) t_{n}
\end{array} .\]

You may notice that some summands have become oversimplified. For example \(((4 n - 10) a o s - (2 n - 6) l^2 s - (2 n - 5) l s^2) t_{n - 3}\) has become \(t_{n-3}\), which could be interpreted as simply set of trees of size \(n - 3\) without any pointing.

\subsection{Transformator framework}%
\label{sub:the_framework}

We also created a~framework~\cite{transformator}, called Transformator, that may help visualize our work on binary trees. It is based on the idea that every transformation expressed in bijective language can be seen as a~function transforming some node and a finite number of its surrounding nodes. \todo{Fix it}This function cannot discriminate between nodes on the grounds of their kind. The only discrimination criteria that may occur may be connected to the following cases:
\begin{itemize}
    \item node has no children, i.e.~is a~virtual leaf (which corresponds to the size of the tree, \(n\));
    \item node has has children, i.e.~is not a~virtual leaf (which corresponds to \(n - 1\));
    \item node is a~root (which corresponds to \(1\));
    \item node has its parent on the left, i.e.~is right child of its parent;
    \item node has its parent on the right, i.e.~is the left child of its parent.
\end{itemize}
\todo{Fix it}

The latest two are introduced in order to make the analysis simpler, but do not have immediate interpretation in the world of holonomic recurrences. If we use them both, it sums up to all nodes except root (as root is neither left nor right child).


\subsection{Transformation classes}%
\label{sub:transformation_classes}

\todo{Introduce contexts with holes}
We will be operating on transformation classes, sections and parts. Let's define them:

\begin{definition}
    Class \(T_i\) is defined as a~set of transformations of trees of size \((n - i)\) into trees of size \(n\).
\end{definition}

\begin{definition}
    Section \(T_{i,j}\) is defined as a~subset of \(T_i\) adding a~specific set of nodes. Webassign \(j\) according to the lexicographical order of lexicographically sorted node types.
\end{definition}

\begin{definition}
    Part \(T_{i,j,k}\) is defined as a~single transformation in section \(T_{i,j}\). \(k\) is assigned according to the order of discovering the transformation.
\end{definition}

In order to make interpretation more human readable, we will be using local notation:

\begin{definition}
    In the context of \(T_i\), \(k\) is defined as \((n - i)\).
\end{definition}

\begin{definition}
    In the context of \(T_i\), \(C_k\) is defined as \(T(n - i)\), i.e.~number of tree transformations from \(T_i\) are working on.
\end{definition}

\begin{definition}
    Section equation \(E_{i, j}\) is an~equation defined in the context of \(T_i\) that evaluates to a~total number of trees that should be generated by transformations from \(T_{i, j}\).
\end{definition}

\begin{definition}
    Section expression \(S_{i, j}\) is a~pair of section equations and a~set of kinds of nodes the transformation introduces.
\end{definition}

For the problem of interpreting trees of lambda terms we define following section expressions:

\[\begin{array}{rccrlc}
        S_{0,0} &=& (& (k + 1) C_k,& \emptyset &)\\
        S_{1,0} &=& (& - (2 k + 1) C_k,& \{l\} &)\\
        S_{1,1} &=& (& - 2 (k + 1) C_k,& \{s\} &)\\
        S_{2,0} &=& (& - (4 k) C_k,& \{ao\} &)\\
        S_{2,1} &=& (& (k) C_k,& \{ll\} &)\\
        S_{2,2} &=& (& (4 k + 2) C_k,& \{ls\} &)\\
        S_{2,3} &=& (& (k + 1) C_k,& \{ss\} &)\\
        S_{3,0} &=& (& 2 (2 k + 1) C_k,& \{aos\} &)\\
        S_{3,1} &=& (& - (2 k) C_k,& \{lls\} &)\\
        S_{3,2} &=& (& - (2 k + 1) C_k,& \{lss\} &)\\
        S_{4,0} &=& (& k C_k,& \{llss\} &)\\
\end{array}\]

Using context-based variables makes the equation simpler to interpret, as we can immediately see the relation between \(k\) and multiplier.

\subsection{Iteration}%
\label{sub:iteration}

As we want to make our work kind of organized, we are going to divide the process of finding interpretation into iterations. Each iteration should be a~small step into the direction of solving the original problem.

We are going to generate two kinds of trees: positive and negative ones. When computing the total number of trees of a given size, we count positive trees as \(1\) and negative as \(-1\). Our goal is to generate \(E_{i, j}\) trees for each section \(T_{i, j}\).

Our brains like small examples, so we will consider small \(n = 3\). This will cause some classes to be empty at the beginning, but it's ok. That's less trees to look at.


\begin{lstlisting}
=== Classes stats ===
[ ]  0,0:       0 of      16 | (k + 1) * Ck              []
[ ]  1,0:       0 of     -10 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:       0 of     -12 | - 2 * (k + 1) * Ck        [s]
[ ]  2,0:       0 of      -4 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of       1 | (k) * Ck                  [ll]
[ ]  2,2:       0 of       6 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of       2 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of       2 | 2 * (2 * k + 1) * Ck      [aos]
[x]  3,1:       0 of       0 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of      -1 | - (2 * k + 1) * Ck        [lss]
[x]  4,0:       0 of       0 | k * Ck                    [llss]
\end{lstlisting}

This statistic tells us for each section, how many trees have been generated of the expected total number of trees in that section. \verb|[x]| means that we generated enough trees for such a~section.

We start with interpreting \(E_{0,0} = (k + 1) C_k\). From statistics above, we see that we should generate \(16\) trees. \((k + 1)\) suggests pointing to a~virtual leaf. Let's do so.

\begin{lstlisting}
c.define_class(0)

c.define_section(0)

c.append_r_class_subtree_visitor(1,       # we define positive trees
                                          # i.e. that count as 1
    lambda kind, left, right:
        None if kind[0] is not None else  # we ignore all actual nodes
        [kind + ("*", )] + left + right   # for each virtual node we point it
)
\end{lstlisting}

\begin{lstlisting}
# define 0,0: (k + 1) * Ck []
=== Classes stats ===
[x]  0,0:      16 of      16 | (k + 1) * Ck              []
[ ]  1,0:       0 of     -10 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:       0 of     -12 | - 2 * (k + 1) * Ck        [s]
[ ]  2,0:       0 of      -4 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of       1 | (k) * Ck                  [ll]
[ ]  2,2:       0 of       6 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of       2 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of       2 | 2 * (2 * k + 1) * Ck      [aos]
[x]  3,1:       0 of       0 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of      -1 | - (2 * k + 1) * Ck        [lss]
[x]  4,0:       0 of       0 | k * Ck                    [llss]
=== Diff stats ===
0,0:     0    16
\end{lstlisting}

The framework informs us that we have generated all trees for section \(0,0\) for \(n = 3\). It also can provide us with the visualization of the trees we have generated. For example:

\includeinlinesvg{.19}{lambda__trees_00__4_base}%
\(\Rightarrow\)
\includeinlinesvg{.19}{lambda__trees_00__4}%
\includeinlinesvg{.19}{lambda__trees_00__5}%
\includeinlinesvg{.19}{lambda__trees_00__6}%
\includeinlinesvg{.19}{lambda__trees_00__7}%

If we take a~look at more examples from class \(0\), we can start seeing some patterns:

(1)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__2}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__3}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__7}%
\end{center}\end{minipage}

(2)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__4}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__12}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__13}%
\end{center}\end{minipage}

(3)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__0}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__1}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__5}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__6}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__14}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__15}%
\end{center}\end{minipage}

(4)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__8}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__9}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__10}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__11}%
\end{center}\end{minipage}

The order may be a~bit suggestive. Section \(1,0\) adds a~single \(l\) node, whereas section \(1,1\) adds a~single \(s\) node. It actually suggests how we can try to generate the first and second line of the trees above. The first one is simple. Let's add \(l\) node with pointed right virtual leaf above each actual node:

\begin{lstlisting}
c.define_class(1)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,                # negative node
    lambda kind, left, right:
        None if kind[0] is None else                # we ignore all virtual nodes
        ["l", kind] + left + right + [(None, "*")]  # for each actual node we add
                                                    # l node with right virtual
                                                    # node pointed as a~parent
)
\end{lstlisting}
\todo{Repeat in natural language}

It creates following trees:
\todo{Mark transformed nodes}

\includeinlinesvg{.24}{lambda__trees_100__0_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__0}%
\includeinlinesvg{.24}{lambda__trees_100__1_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__1}%

\includeinlinesvg{.24}{lambda__trees_100__2_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__2}%
\includeinlinesvg{.24}{lambda__trees_100__3_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__3}%

It addresses all cases from the first line, but also introduces an~incorrect lambda tree in which \(s\) is the parent of \(l\), which cannot happen. We will fix it with the section \(2,2\) generating positive trees, which introduces one \(l\) node and one \(s\) by extending the tree with \(2\) nodes where \(s\) is parent of \(l\).

Next, we can take care of next cases of section \(0, 0\). It can be also expressed using sections \(1, 0\) and \(1, 1\):

\begin{lstlisting}
c.define_class(1)

c.define_section(0)

# old visitor
c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["l", kind] + left + right + [(None, "*")]
)

# new visitor
c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + [left[0] + ("*",)] + left[1:] + right + [None]
)

# new visitor
c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + left + [right[0] + ("*",)] + right[1:] + [None]
)

c.define_section(1)

# old visitor
c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)

# new visitor
c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + left + [right[0] + ("*",)] + right[1:]
)

# new visitor
c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + [left[0] + ("*",)] + left[1:] + right
)
\end{lstlisting}

Basically, for each virtual leaf not being root (i.e.~having left or right parent), we point it and add \(l\) or \(s\) respectively above the parent.

\includeinlinesvg{.32}{lambda__trees_111__1_base}%
\(\Rightarrow\)
\includeinlinesvg{.32}{lambda__trees_101__0}%
\includeinlinesvg{.32}{lambda__trees_112__0}%

The last row can be generated using section \(2, 0\):

\begin{lstlisting}
c.define_class(2)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", (None, "*"), None, kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", None, (None, "*"), kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", (None, "*"), None]
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", None, (None, "*")]
)
\end{lstlisting}

For each actual vertex, we add \(a\) node as its left or right parent and add as a~second child \(o\) node as its sibling. We then point to the left or right virtual child of the newly created \(o\) node.

\includeinlinesvg{.20}{lambda__trees_200__0_base}%
\(\Rightarrow\)
\includeinlinesvg{.20}{lambda__trees_200__0}%
\includeinlinesvg{.20}{lambda__trees_201__0}%
\includeinlinesvg{.20}{lambda__trees_202__0}%
\includeinlinesvg{.20}{lambda__trees_203__0}%

After such transformations, we get following statistics:

\begin{lstlisting}
=== Classes stats ===
[x]  0,0:      16 of      16 | (k + 1) * Ck              []
[x]  1,0:     -10 of     -10 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:      -9 of     -12 | - 2 * (k + 1) * Ck        [s]
[x]  2,0:      -4 of      -4 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of       1 | (k) * Ck                  [ll]
[ ]  2,2:       0 of       6 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of       2 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of       2 | 2 * (2 * k + 1) * Ck      [aos]
[x]  3,1:       0 of       0 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of      -1 | - (2 * k + 1) * Ck        [lss]
[x]  4,0:       0 of       0 | k * Ck                    [llss]
=== Diff stats ===
1,0:     4     0
1,1:     3     0
\end{lstlisting}

This construction works also for bigger \(N\):

\begin{lstlisting}
=== Classes stats ===
[x]  0,0:   39050 of   39050 | (k + 1) * Ck              []
[x]  1,0:  -23237 of  -23237 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:  -17799 of  -24460 | - 2 * (k + 1) * Ck        [s]
[x]  2,0:  -13728 of  -13728 | - (4 * k) * Ck            [ao]
[ ]  2,1:       0 of    3432 | (k) * Ck                  [ll]
[ ]  2,2:       0 of   14586 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:       0 of    3861 | (k + 1) * Ck              [ss]
[ ]  3,0:       0 of    4620 | 2 * (2 * k + 1) * Ck      [aos]
[ ]  3,1:       0 of   -2156 | - (2 * k) * Ck            [lls]
[ ]  3,2:       0 of   -2310 | - (2 * k + 1) * Ck        [lss]
[ ]  4,0:       0 of     342 | k * Ck                    [llss]
=== Diff stats ===
1,0:  7602     0
1,1:  5832     0
2,0:  2280     0
\end{lstlisting}

The process can then be repeated for each section. We have chosen lexicographical order (i.e.~\(0,0\); \(1,0\); \(1,1\); \(2,0\); \(\ldots\)).

\subsection{Final result}%
\label{sub:final_result}

After multiple iterations, we managed to come up with following construction:

\begin{lstlisting}
c.define_class(0)

c.define_section(0)

c.append_r_class_subtree_visitor(1,
    lambda kind, left, right:
        None if kind[0] is not None else
        [kind + ("*", )] + left + right
)


c.define_class(1)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["l", kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + [left[0] + ("*",)] + left[1:] + right + [None]
)

c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", parent_kind] + left + [right[0] + ("*",)] + right[1:] + [None]
)

c.define_section(1)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)

c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + left + [right[0] + ("*",)] + right[1:]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + [left[0] + ("*",)] + left[1:] + right
)


c.define_class(2)

c.define_section(0)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", (None, "*"), None, kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", "o", None, (None, "*"), kind] + left + right
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", (None, "*"), None]
)

c.append_r_class_subtree_visitor(-1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["a", kind] + left + right + ["o", None, (None, "*")]
)

c.define_section(1)

c.append_r_class_subtree_visitor(1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["l", "l", kind] + left + right + [(None, "*"), None]
)

c.define_section(2)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["l", "s", (None, "*"), parent_kind] + left + right + [None]
)

c.append_r_class_subtree_visitor(1,
    lambda kind, left, right:
        None if kind[0] is None else
        ["s", None, "l", kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", parent_kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", parent_kind] + [left[0] + ("*", )] + left[1:] + right + [None]
)

c.append_r_class_left_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", parent_kind] + left + [right[0] + ("*", )] + right[1:] + [None]
)


c.define_section(3)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "s", (None, "*"), parent_kind] + left + right
)


c.define_class(3)

c.define_section(0)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", "o", (None, "*"), None, parent_kind] + left + right
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", "o", None, (None, "*"), parent_kind] + left + right
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", parent_kind] + left + right + ["o", (None, "*"), None]
)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "a", parent_kind] + left + right + ["o", None, (None, "*")]
)

c.define_section(1)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", "l", parent_kind] + left + right + [(None, "*"), None]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        ["s", None, "l", "l", parent_kind] + left + right + [(None, "*"), None]
)


c.define_section(2)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "s", None, "l", parent_kind] + left + right + [(None, "*")]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "l", "s", (None, "*"), parent_kind] + left + right + [None]
)


c.define_class(4)

c.define_section(0)

c.append_r_class_right_parent_subtree_visitor(1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, "s", None, "l", "l", parent_kind] + left + right + [(None, "*"), None]
)
\end{lstlisting}

It resulted in final statistics:

\begin{lstlisting}
=== Classes stats ===
[x]  0,0:   39050 of   39050 | (k + 1) * Ck              []
[x]  1,0:  -23237 of  -23237 | - (2 * k + 1) * Ck        [l]
[ ]  1,1:  -17799 of  -24460 | - 2 * (k + 1) * Ck        [s]
[x]  2,0:  -13728 of  -13728 | - (4 * k) * Ck            [ao]
[x]  2,1:    3432 of    3432 | (k) * Ck                  [ll]
[ ]  2,2:   10833 of   14586 | (4 * k + 2) * Ck          [ls]
[ ]  2,3:    1770 of    3861 | (k + 1) * Ck              [ss]
[ ]  3,0:    2280 of    4620 | 2 * (2 * k + 1) * Ck      [aos]
[ ]  3,1:   -1648 of   -2156 | - (2 * k) * Ck            [lls]
[ ]  3,2:   -1140 of   -2310 | - (2 * k + 1) * Ck        [lss]
[ ]  4,0:     187 of     342 | k * Ck                    [llss]
=== Diff stats ===
\end{lstlisting}

As you can see, diff stats are empty, so we managed to generate expected trees on both sides of the equation.

You may also note that we did not generate all trees suggested by the recurrence. This is due to one cheat we used.

\subsection{The cheat}%
\label{sub:the_cheat}

You may remember our assumptions in Section~\ref{sub:the_framework} about the discrimination cases. We allowed ourselves to apply visitors only to one of the left and right children, which is not handled by our holonomic recurrence as the number of such vertices does not depend only on \(n\).

To fix this, one can for example add construction for section \(1, 0\) to generate all expected trees from it and then repeat the iteration in order to generate matching trees on the other side of the equation. We can see that we used \(2\) constructions visiting nodes with right parent and only one visiting node having left parent, so our missing construction should also visit nodes with left parent.

\begin{lstlisting}
c.define_class(1)

c.define_section(0)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)

c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + left + [right[0] + ("*",)] + right[1:]
)

c.append_r_class_right_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", None, parent_kind] + [left[0] + ("*",)] + left[1:] + right
)

# example missing construction
c.append_r_class_left_parent_subtree_visitor(-1,
    lambda kind, parent_kind, left, right:
        None if kind[0] is not None else
        ["s", (None, "*"), parent_kind] + left + right
)
\end{lstlisting}

Please note that it is only an~example of missing construction. It is just the simplest one we could think about, and in that case, a~simple solution is most often the correct one.

\section{Further work}%
\label{sec:further_work}

First thing to be done, that comes to mind immediately, is to finish the construction eliminating the cheat mentioned in Section~\ref{sub:the_cheat}.

You may also note that we are operating on specific \(N\). The probability that we miss some corner case is low, but even if we check large \(N\) values, it is always present. The formal algebraic proof would make us sure that the construction works. We would prioritize finishing the construction first.

The framework also is not perfect. It highly depends on the operator's intuition. We believe that the solving process can be automated. The simplest method that comes to mind is simply creating heuristic rules that then will be used by the framework to guess at least partial solutions.

With the proper interpretation, it may be possible to create a~sampling algorithm similar to Rémy's one for binary trees~\cite{remy,note}. It would have to take under consideration that some trees are being removed by other classes, so the probabilities would have to be set carefully.

We believe that one day all of that will be done or proven to be impossible.

\clearpage

\printbibliography

\end{document}
