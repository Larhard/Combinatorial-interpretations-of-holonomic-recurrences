\documentclass[final]{article}
\usepackage{todonotes}
\setlength{\marginparwidth}{2.5cm}
\RequirePackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{
\DeclareUnicodeCharacter{25CF}{\(\n\)}
\RequirePackage{color}
\definecolor{ao(english)}{rgb}{0.0,
0.5,
0.0}
\definecolor{blue(pigment)}{rgb}{0.2,
0.2,
0.6}
\definecolor{egyptianblue}{rgb}{0.06,
0.2,
0.65}
\definecolor{lightgray}{gray}{0.60}
\RequirePackage{listings}
\lstset{
basicstyle=\footnotesize\ttfamily,
comment=[l]{\#},
morecomment=[s]{/*}{*/},
commentstyle=\color{lightgray}\ttfamily,
escapeinside={<@}{@>}
\RequirePackage{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=black,
citecolor=black,
filecolor=black,
urlcolor=black
\RequirePackage{geometry}
\RequirePackage{tabularx}
\RequirePackage{longtable}
\RequirePackage{graphicx}
\RequirePackage{svg}
\RequirePackage{float}
\svgpath{images/}
\RequirePackage[maxbibnames=99]{biblatex}
\addbibresource{bibliography.bib}
\RequirePackage{amsthm}
\RequirePackage{amsmath}
\RequirePackage{mathtools}
\RequirePackage{amsfonts}
\RequirePackage{soul}
\RequirePackage{xspace}
\RequirePackage{bussproofs}
\RequirePackage[customcolors]{hf-tikz}
\RequirePackage{tikz}
\RequirePackage{setspace}
\RequirePackage{multicol}
\RequirePackage{lipsum}
\RequirePackage{textpos}
\setlength{\parindent}{0pt}
\setlength{\parskip}{.7em}
\title{Combinatorial
interpretations
of~holonomic
recurrences}
\author{Bart
omiej
Puget}
\date{\today}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsection]
\theoremstyle{definition}
\newtheorem{interpretation}{Interpretation}[subsection]
\theoremstyle{remark}
\newtheorem{example}{Example}[subsection]
\newcounter{highlightid}
\newcommand{\mhl}[1]{{\tikzmarkin[set
fill
color=red!30,set
border
color=red]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}
\newcommand{\mhll}[1]{{\tikzmarkin[set
fill
color=red!30,set
border
color=red]{highlight-\arabic{highlightid}}(0.15,-0.15)(-0.15,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}
\newcommand{\mhlr}[1]{{\tikzmarkin[set
fill
color=red!30,set
border
color=red]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}
\newcommand{\mhlg}[1]{{\tikzmarkin[set
fill
color=green!30,set
border
color=green]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}
\newcommand{\mhlb}[1]{{\tikzmarkin[set
fill
color=blue!30,set
border
color=blue]{highlight-\arabic{highlightid}}(0.02,-0.15)(-0.02,0.35){#1}\tikzmarkend{highlight-\arabic{highlightid}}\stepcounter{highlightid}}}
\newcommand{\ols}[1]{\mskip.5\thinmuskip\overline{\mskip-.5\thinmuskip
{#1}
\mskip-.5\thinmuskip}\mskip.5\thinmuskip}
overline
short
\newcommand{\olsi}[1]{\,\overline{\!{#1}}}
overline
short
italic
\newcommand{\gf}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\enc}[1]{\ensuremath{\ols{#1}}}
\newcommand{\pointed}[1]{\ensuremath{{#1}^*}}
\newcommand{\weighted}[1]{\ensuremath{_{(#1)}}}
\newcommand{\size}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\LambdadB}{\ensuremath{\Lambda_{\text{dB}}}}
\DeclareMathOperator{\textiff}{\text{iff}}
\DeclareMathOperator{\N}{\mathbb{N}}
\DeclareMathOperator{\poly}{\mathbb{P}}
\DeclareMathOperator{\troot}{\text{root}}
\DeclareMathOperator{\tleft}{\text{left}}
\DeclareMathOperator{\tright}{\text{right}}
\DeclareMathOperator{\tLeft}{\text{Left}}
\DeclareMathOperator{\tRight}{\text{Right}}
\DeclareMathOperator{\tSub}{\text{Sub}}
\DeclareMathOperator{\tPre}{\text{Pre}}
\DeclareMathOperator{\tSuf}{\text{Suf}}
\DeclareMathOperator{\n}{\bullet}
\DeclareMathOperator{\no}{\o}
\newcommand{\includeinlinesvg}[2]{\begin{minipage}{#1\textwidth}\includesvg[width=\textwidth]{#2}\end{minipage}}
\newcommand{\includeinlinescaledsvg}[3]{\begin{minipage}{#1\textwidth}\begin{center}\includesvg[scale=#2]{#3}\end{center}\end{minipage}}
\begin{document}
\begin{titlepage}
	\begin{center}
	\textsc{\LARGE
Jagiellonian
University}
	\Large
Faculty
Mathematics
Computer
Science
	\Large
Theoretical
Computer
Science
	\vfill
	\vspace{1cm}
	\hrulefill
	\vspace{0.5cm}
\makeatletter
\huge
\textsc{\@title}
\makeatother
	\vspace{0.2cm}
	\hrulefill
	\vspace{1cm}
\makeatletter
	\textsc{\Large
\@author}
\makeatother
	\vspace{1cm}
\normalsize
	Master
Thesis\\
	Advisor:
\textsc{Katarzyna
Grygiel}
	\vfill
\makeatletter
\@date
\makeatother
	\end{center}
\end{titlepage}
\section*{Abstract}%
\label{sec:abstract}
analyze
problem
finding
combinatorial
interpretations
holonomic
recurrences
show
some
techniques
that
were
used
achieve
known
results.
also
find
a~combinatorial
interpretation
holonomic
recurrence
trees
lambda
terms
Bruijn
notation.
\clearpage
\tableofcontents
\clearpage
\section{Overview}%
Generating
functions
describing
infinite
sequences
using
formal
power
series,
where
coefficients
encode
consecutive
elements.
allows
incorporate
many
advanced
methods
analysis
encoded
objects.
Every
recursive
structure
described
using
a~generating
function
equation,
which
then
solved
transformed
into
a~holonomic
recurrence,
i.e.~recurrence
that
order
define
\(n\)-th
element
sequence
requires
just
finite
number
previous
ones
coefficients
that
polynomials
\(n\).
allows
quickly
count
objects
given
structure
with
given
size.
first
glance,
recurrence
seems
closely
related
structure
itself.
just
seems
like
should
describe
simple
transformations
resulting
constructing
bigger
objects
from
slightly
smaller
ones.
case
trees
could
example
adding
vertices.
However,
there
known
method
interpreting
language
combinatorial
structures.
today
only
interpretations
holonomic
recurrences
trees
have
been
found,
including
interpretation
holonomic
recurrences
binary
trees~\cite{binary},
unary-binary
trees~\cite{motzkin},
Schr
trees~\cite{schroder}.
Unfortunately,
mentioned
interpretations
come
with
method
finding
them
that
could
generalized
more
complex
cases.
initial
inspiration
thesis
came
from
publication
\textit{A
natural
counting
lambda
terms}~\cite{inspiration},
which
shows
bijections
among
seemingly
different
tree
structures,
which
lambda
trees,
black-white
trees~\cite{blackwhite}
zigzag
free
trees~\cite{inspiration}\todo{Find
better
cite}.
They
share
same
holonomic
recurrence,
there
known
immediate
connection
between
holonomic
recurrence
structures
itself.
Lambda
terms
very
popular
structures
used
analyzing
functions
programming
languages.
Their
very
simple
recursive
definition
makes
them
very
attractive.
Better
understanding
them
could
allow
improving
programming
language
compilers
consequence
improve
every
aspect
lives.
interpretation
holonomic
recurrence
lambda
trees
itself
could
allow
discover
ways
generating
random
lambda
terms
extending
smaller
ones
similar
my's
algorithm
sampling
binary
trees~\cite{remy,note}.
Throughout
thesis
accumulate
known
results
techniques
that
help
solving
problem
finding
combinatorial
interpretations.
also
propose
an~approach
that
helped
find
an~intermediate
solution
problem
finding
combinatorial
interpretation
holonomic
recurrence
lambda
trees
unary
Bruijn
notation.
Bruijn
indices
order
letter-based
variable
names.
Unary
notation
allows
connect
size
tree
values
Bruijn
indices.
Section~\ref{sec:introduction}
establish
notation
introduce
concepts
that
will
used
throughout
thesis.
Next,
Section~\ref{sec:known_results},
present
known
results,
i.e.~interpretations
binary
trees,
unary-binary
trees
Schr
trees.
They
demonstrate
different
approaches
problem.
Section~\ref{sec:approaches}
show
approaches
problem
that
helped
achieve
aforementioned
results.
them
were
tried
order
find
answer
original
problem
interpreting
holonomic
recurrence
trees
lambda
terms
unary
Bruijn
notation.
Unfortunately,
none
them
helped
enough
final
result.
Anyway,
they
proven
helpful
when
stuck,
most
them
able
divide
problems
into
smaller
parts
detect
corner
cases.
Section~\ref{sec:brutal_iterative_approach}
presents
final
approach
original
problem,
i.e.~computer-aided
iterative
approach
that
allowed
find
intermediate
solution.
believe
that
possible
extend
this
idea
order
obtain
full
solution,
were
able
achieve
that
limited
time
that
available
Finally,
Section~\ref{sec:further_work},
present
view
what
done
with
problem
future.
believe
that
problem
will
fully
solved
a~more
generic
approach
interpreting
holonomic
recurrences
will
emerge.
\clearpage
\section{Introduction}%
\label{sec:introduction}
\subsection{Notation}%
\label{sub:notation}
order
make
reading
this
thesis
easier,
let's
some
notation
make
some
assumptions.
deviation
from
this
will
clearly
stated.
have
trouble
guessing
what
some
letter
word
means,
this
should
your
primary
place
look
answer.
e.g.~stands
Latin
exempli
gratia,
which
means
\textit{for
example}.
i.e.~stands
Latin
est,
which
means
\textit{that
is}.
\(\textiff\)
means
only
\(\poly\)
a~set
polynomials.
\(n,
implicitly
assumed
natural
numbers.
\(f,
implicitly
assumed
functions.
\(f^{(n)}\)
implicitly
defined
\(n\)-th
derivative
function
\(f\).
\(V(T)\)
implicitly
defined
a~set
nodes
tree
\(T\).
\(E(T)\)
implicitly
defined
a~set
edges
tree
\(T\).
\(u,
implicitly
assumed
nodes.
\(e\)
implicitly
assumed
an~edge.
\(\troot(T)\)
implicitly
defined
a~root
tree
\(T\).
\(\tleft(v)\)
implicitly
defined
a~left
child
node
\(v\).
\(\tright(v)\)
implicitly
defined
a~right
child
node
\(v\).
\(\tSub(v)\)
implicitly
defined
a~whole
subtree
rooted
with
node
\(v\).
\(\tLeft(v)\)
implicitly
defined
a~left
subtree
node
\(v\).
\(\tRight(v)\)
implicitly
defined
a~right
subtree
node
\(v\).
Sibling
node
\(v\)
defined
node
\(u\)
having
same
parent
\(v\).
Uncle
node
\(v\)
defined
a~sibling
parent
\(v\).
that
node
\(v\)
an~oneling
\(\textiff\)
\(v\)
siblings.
Note
that
root
oneling
even
parent.
that
node
\(v\)
twinling
\(\textiff\)
\(v\)
least
sibling.
Leaf
a~node
which
children.
\(\n\)
implicitly
defined
a~default
identifier
a~node.
\(\no\)
implicitly
defined
an~identifier
a~non-existing
node
(e.g.~if
\(v\)
a~leaf,
\(\tleft(v)
\n\)).
Dashed
edges
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__dashed_edge}
\end{minipage}
depict
edges
that
exist
(e.g.~when
describe
transformations
care
node
root
children).
Green
edges
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__green_edge}
\end{minipage}
depict
edges
\(\no\)
nodes.
Virtual
node
an~artificially
defined
node
that
does
affect
structure
definition
(e.g.~we
define
virtual
leafs
that
children
actual
leaves
binary
tree.
Such
virtual
leaves
included
when
counting
number
children
node,
actual
leaves
still
called
leaves).
Actual
node
a~node
that
virtual.
that
node
\(v\)
an~virtual-oneling
\(\textiff\)
\(v\)
siblings
being
virtual
nodes.
that
node
\(v\)
virtual-twinling
\(\textiff\)
\(v\)
least
sibling
being
virtual
node.
a~binary
tree,
that
node
\(v\)
right
(left)
\(\textiff\)
\(v\)
a~right
(left)
child
parent.
a~binary
tree,
that
node
\(v\)
a~right
(left)
parent
\(u\)
\(\textiff\)
\(v\)
a~left
(right)
child
\(u\).
\(\pointed{v}\)
implicitly
defined
a~pointed
node
\(v\).
treat
a~node
with
an~additional
label
\(\pointed{}\).
\(v\weighted{n}\)
implicitly
defined
a~weighted
node
\(v\)
with
weight
\(n\).
\(x_i\)
implicitly
assumed
an~\(i\)-th
element
sequence
\(X\),
where
\(x\)
lower-case
letter
\(X\)
upper-case
\(x\).
Calligraphic
\(\gf{X}\)
implicitly
assumed
a~generating
function
sequence
\(X\)
where
\(X\)
upper-case
letter.
\(\size{X}\)
implicitly
defined
size
object
\(X\).
\subsection{Structurally
recursive
objects}%
\label{sub:structurally_recursive_objects}
will
analyzing
structures
that
expressed
using
recursive
formulas.
example
define
a~full
binary
tree
recursively
a~node
having
children
(i.e.~being
a~leaf)
having
exactly
subtrees
being
full
binary
trees.
express
disjoint
alternative
construction
rule,
\(+\).
reason
will
become
obvious
soon.
\begin{figure}[H]
\begin{center}
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\(B\)\\
\includesvg[scale=0.5]{binary__def_1}%
\end{center}
\end{minipage}%
\begin{minipage}[t]{.05\textwidth}
\begin{center}
\(=\)\\
\end{center}
\end{minipage}%
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\(\text{leaf}\)\\
\includesvg[scale=0.5]{binary__def_2}%
\end{center}
\end{minipage}%
\begin{minipage}[t]{.05\textwidth}
\begin{center}
\(+\)\\
\end{center}
\end{minipage}%
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\(B^2\)\\
\includesvg[scale=0.5]{binary__def_3}%
\end{center}
\end{minipage}%
\end{center}
\caption{Binary
tree
recursive
definition.}%
\label{fig:binary_recursion}
\end{figure}
\subsection{Generating
functions}%
\label{sub:generating_functions}
\todo{Source}
\todo{Make
section
simpler}
Throughout
thesis
ordinary
generating
functions
describe
count
structures.
\begin{definition}
ordinary
generating
function
sequence
{(a_i)}_{i=0}^{\infty}\)
defined
a~formal
power
series:
\[\gf{A}(z)
\sum_{i=0}^{\infty}
z^i.\]
\end{definition}
Note
that
order
compute
\(k\)-th
element
sequence,
namely
\(a_k\),
just
need
find
a~constant
corresponding
indeterminate
\(z^k\).
have
sequence
counting
some
objects
corresponding
generating
function,
that
this
function
counts
objects.
\begin{example}%
\label{ex:bin_gf}
Let's
consider
recursive
definition
binary
trees
shown
Figure~\ref{fig:binary_recursion}.
create
a~functional
equation
count
trees
with
exactly
internal
nodes.
make
internal
nodes
contribute
generating
function
with
\(z^1
leaves
with
\(z^0
1\):
\[\gf{B}(z)
z\gf{B}^2(z).\]
order
some
intuition
works
underneath,
let's
take
a~look
find
number
full
binary
trees
size
\(2\).
expand
recurrence
a~bit:
\[\begin{array}{rclr}
\gf{B}(z)
z\gf{B}^2(z)\\
z\bigg(1
z\gf{B}^2(z)\bigg)\bigg(1
z\gf{B}^2(z)\bigg)\\
\mhl{z}\bigg(1
\mhl{z}\Big(\mhl{1}
z\gf{B}^2(z)\Big)\Big(\mhl{1}
z\gf{B}^2(z)\Big)\bigg)\bigg(\mhl{1}
z\gf{B}^2(z)\bigg)
&(*)\\
z\bigg(1
z\Big(1
z\gf{B}^2(z)\Big)\Big(1
z\gf{B}^2(z)\Big)\bigg)\bigg(1
z\Big(1
z\gf{B}^2(z)\Big)\Big(1
z\gf{B}^2(z)\Big)\bigg)\\
\bigg(2
\gf{B}^2(z)
{\Big(1
\gf{B}^2(z)\Big)}^2\bigg)
\end{array}\]
enough,
term
\(\bigg(2
\gf{B}^2(z)
{\Big(1
\gf{B}^2(z)\Big)}^2\bigg)
z^3\)
will
contribute
only
\(z^k\)
where
2\).
Therefore,
that
there
\(2\)
trees
with
exactly
\(2\)
internal
nodes,
multiplier
next
\(z^2\)
\(2\).
visualize
even
more,
let's
take
a~look
line
marked
with
\((*)\).
highlighted
terms
describe
following
tree:
\begin{figure}[H]
\begin{center}
\includesvg[scale=.7]{intro__iilll}
\end{center}
\caption{Tree
corresponding
highlighted
terms
\((*)\).}%
\label{fig:tree_corresponding_to_mhl}
\end{figure}
\end{example}
There
exist
multiple
well-known
methods
tools
that
allow
work
with
generating
functions
without
need
digging
into
details.
tool
will
using
extensively
this
work
Maple
package
called
GFUN~\cite{gfun}.
want
learn
more
about
algorithms
used
package,
strongly
encourage
reading
referenced
article.
\subsection{Holonomic
recurrences}%
\label{sub:holonomic_recurrences}
\todo{Extend
section}
Since
most
time
will
working
with
holonomic
recurrences,
let's
introduce
them.
\begin{definition}[\cite{holotoolkit}]%
\label{def:holo_1}
infinite
sequence
{(a_i)}_{i=0}^{\infty}\)
holonomic
(aka.
P-finite,
P-recursive
D-recursive)
\(\textiff\)
there
exists
a~holonomic
recurrence
i.e.
\[\exists_{r
\exists_{p_0,
\ldots,
\poly}
\forall_{n
\sum_{i=0}^r
p_i(n)a_{n+i}
0.\]
\end{definition}
Note
that
only
take
a~finite
number
subsequent
elements
sequence
\(A\)
into
relation.
\begin{example}
sequence
\(a_n
\frac{5n
3}{3n
5}\)
holonomic,
because
satisfies
\[(3n
5)(5n
3)(3n
a_{n+1}
0.\]
\end{example}
\begin{example}
Sequences
\(a_n
\sqrt{n}\),
\(b_n
n^n\)
\textbf{not}
holonomic,
i.e.~none
them
satisfies
a~linear
recurrence
equation
with
polynomial
coefficients~\cite{nonholo}.
\end{example}
\begin{definition}[\cite{complexity}]%
\label{def:holo_2}
Equivalently
Definition~\ref{def:holo_1},
{(a_i)}_{i=0}^{\infty}\)
holonomic
\(\textiff\)
there
exists
a~generating
function
following
form:
\[\sum_{i=0}^{r}
p_i(z)
\gf{A}^{(i)}(z)
b(z)\]
some
fixed
\N\);
\(b,
p_0,
\ldots,
\poly\)
identical
zero.
\end{definition}
equivalence
these
definitions
assures
that
find
an~generating
function
equation
describing
desired
objects
satisfying
Definition~\ref{def:holo_2},
will
able
find
holonomic
recurrence
mentioned
Definition~\ref{def:holo_1}~\cite{complexity}.
\begin{example}%
\label{ex:gfun-rec}
generating
function
counting
full
binary
trees
defined
Example~\ref{ex:bin_gf},
i.e.:
\[\gf{B}(z)
z\gf{B}^2(z)\]
GFUN~\cite{gfun}
immediately
find
a~holonomic
recurrence
interest:
\begin{lstlisting}
with(gfun):
RootOf(B
B^2*z
RootOf(_Z
algfuntoalgeq(%,
B(z));
algeqtodiffeq(%,
B(z));
B(z)
B(z)|
diffeqtorec(%,
B(z),
B(n));
B(n)
B(0)
\end{lstlisting}
holonomic
recurrence
then
\[\left\{\begin{array}{rcl}
b_{n
\end{array}\right..\]
most
interesting
part
relation
among
finite
number
consecutive
elements
sequence.
\end{example}
\subsection{Combinatorial
interpretations}%
\label{sub:combinatorial_interpretations}
Combinatorial
interpretation
just
a~fancy
name
something
probably
know
use.
example
know
binomial
coefficient
\(\binom{n}{k}\),
introduced
something
like:
``let's
assume
have
\(n\)
distinguishable
balls.
want
choose
\(k\)
from
them,
then
\(\binom{n}{k}\)
ways''
now,
whenever
term
\(\binom{n}{k}\),
interpret
number
ways
choose
\(k\)
objects
from
size
\(n\).
This
combinatorial
interpretation
binomial
coefficient.
Holonomic
recurrences
very
useful
want
count
objects
a~given
size.
course,
size
defined
more
complex
ways,
e.g.~we
want
find
number
binary
trees
with
\(n\)
internal
nodes
having
exactly
\(m\)
nodes
being
left
child
parent.
Unfortunately,
there
commonly
known
method
find
their
intuitive
interpretation
world
objects
they
describe.
thesis
gather
methods
results
that
helpful
anyone
trying
find
such
an~interpretation,
believe
that
give
better
insight
into
nature
structure
make
easier
study
structure's
properties.
\subsection{Pre-order
notation}%
\label{sub:pre_order_notation}
thesis,
stated
otherwise,
will
working
rooted
ordered
unlabeled
\(n\)-ary
trees.
understand
terms,
let's
define
them:
\begin{itemize}
\item
rooted
tree
a~tree
with
single
vertex
marked
root.
This
allows
define
hierarchy
nodes
using
such
terms
parent
child;
\item
ordered
trees
introduce
order
children
from
leftmost
rightmost;
\item
unlabeled
trees
have
nodes
that
distinguishable
their
label.
will
introduce
soon
kinds
nodes,
shouldn't
treat
them
labels,
rather
describe
structure
node
that
already
present
(e.g.~we
call
node
with
just
left
child
an~\(l\)
node,
label.
right
child
added
\(l\)
node,
would
an~\(l\)
node
anymore).
\end{itemize}
Additionally
allow
that
\(n\)-ary
node
some
children
unset
(e.g.~we
define
a~binary
node
with
just
left
child
set,
right
one).
order
make
notation
easier
unambiguous,
introduce
pre-order
notation
an~\(n\)-ary
tree.
\begin{definition}
single
vertex
\(v\),
pre-order
notation
defined
\(\enc{v}\).
\end{definition}
Here,
\(\enc{v}\)
defined
follows:
\begin{itemize}
\item
\(v\)
an~existing
node,
\(\enc{v}
\n\);
\item
\(v\)
a~non-existing
node
(i.e.~we
describe
non-existing
child
some
node),
\(\enc{v}
\no\).
\end{itemize}
\begin{definition}
Pre-order
notation
\(n\)-ary
tree
\(T\),
namely
\(\enc{T}\),
defined
recursively
\[\enc{T}
\enc{\troot(T)}
\prod_{i=1}^{n}
\enc{i\text{-th
subtree
\troot(T)}\]
i.e.~catenation
identifier
root
tree
with
encoded
subtrees
from
left
right.
\end{definition}
\begin{figure}[H]
\centering
\includesvg[scale=.7]{intro__oononnn}
\caption{Tree
described
pre-order
notation
\(\n
\no\).}%
\label{fig:oononnn}
\end{figure}
green
edges
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__green_edge}
\end{minipage}
depict
edges
\(\no\)
nodes.
note
that
encoding
a~given
tree
unique.
Unfortunately,
every
sequence
encodes
proper
tree.
also
define
prefixes
suffixes
\(T\)
relation
a~node
\(v\).
\begin{definition}
\(\tSub(v)\)
defined
a~whole
subtree
rooted
with
node
\(v\).
\end{definition}
\begin{definition}
\(v\)
a~node
described
using
\(k\)-th
symbol
\(\enc{T}\).
Notation
prefix
\(T\)
relation
\(v\),
namely
\(\enc{\tPre(T,
v)}\),
defined
a~prefix
\enc{T}
size
1\).
\end{definition}
\begin{definition}
\(n\)
length
sequence
\(\enc{T}\).
Notation
suffix
\(T\)
relation
\(v\),
namely
\(\enc{\tSuf(T,
v)}\),
defined
a~suffix
\enc{T}
size
\size{\enc{\tPre(T,
v)}}
\size{\enc{\tSub(v)}}\).
\end{definition}
other
words,
prefix
tree
\(T\)
relation
\(v\)
describes
a~part
tree
that
appears
before
subtree
rooted
\(v\)
pre-order
notation.
Suffix
describes
part
tree
that
appears
after
\begin{figure}[H]
\centering
\includesvg[scale=.7]{intro__presuf_custom}
\caption{Visualization
prefixes,
suffixes
subtrees}%
\label{fig:presuf}
\end{figure}
Throughout
thesis
define
some
operations
using
this
notation.
Valid
pre-order
notation
\(n\)-ary
tree
(note
that
sequences
valid
pre-order
notations)
easily
translated
back
into
a~tree.
order
just
take
first
symbol
notation
create
root
accordingly.
Then
each
\(n\)
children
root,
sequence,
decode
recursively
whole
tree.
Each
such
operation
consumes
some
prefix
notation.
should
left
with
symbols
sequence.
\(T\)
\(\enc{T}\)
describe
same
structures,
notation
trees
\(T\)
encoding
\(\enc{T}\)
will
used
interchangeably.
\section{Known
results}%
\label{sec:known_results}
this
section
show
combinatorial
interpretations
holonomic
recurrences
binary
trees,
unary-binary
trees
Schr
trees.
knowledge
these
only
tree
classes
that
have
commonly
known
interpretations.
Also
thought
process
leading
these
interpretations
obvious.
Each
these
interpretations
unique
character,
like
different
selection
size
definition
different
approach
arranging
terms
holonomic
recurrence.
These
interpretations
have
been
source
ideas
that
that
were
incorporating
order
make
partial
interpretation
case
lambda
trees
unary
Bruijn
notation.
\subsection{Binary
trees}%
\label{sub:binary_trees}
Let's
start
with
probably
most
known
interpretation,
full
binary
trees~\cite{binary}.
define
size
a~tree
number
internal
nodes
(i.e.~nodes
that
leaves).
generating
function
therefore
a~solution
following
equation
\[\gf{B}(z)
z\gf{B}^2(z)\]
After
a~quick
transformation,
following
holonomic
recurrence:
\[\left\{\begin{array}{rcl}
2)b_{n
1)b_n
\end{array}\right.\]
This
equation
actually
have
\(2\)
solutions,
eliminate
them
assumption
that
counting
objects,
i.e.~we
interested
only
solutions
that
give
natural
numbers.
Numbers
defined
above
also
known
Catalan
numbers.
easy
that
a~tree
size
\(n\)
(i.e.~with
\(n\)
internal
nodes)
leaves
therefore
\(2n
nodes
total.
Analogically
tree
size
leaves
\(2n
nodes
total.
some
resemblance
holonomic
recurrence,
perfectly
right.
going
create
a~bijection
between
left
right
side
recurrence.
will
using
term
\textit{bijective
language}
talk
about
recurrence
using
objects
describes
their
transformations.
\todo{rewrite}
\begin{interpretation}
Let's
translate
recurrence
bijective
language.
\begin{itemize}
\item
\(b_n\)
simply
full
binary
trees
size
\(n\),
\item
\((n
b_{n
1}\)
full
binary
trees
size
with
leaves
pointed,
\item
\((2n
b_{n}\)
full
binary
trees
size
\(n\)
with
nodes
(either
internal
a~leaf)
pointed
(i.e.~distinguished),
\item
\(2\)
beginning
b_{n}\)
indicates
that
will
using
\(2\)
copies
defined
previous
bullet.
\end{itemize}
moment
left
side
recurrence
related
trees
size
1\),
right,
other
hand,
size
\(n\).
Therefore,
need
apply
some
transformations
trees.
Let's
define
local
operations
tree
\(T\)
with
a~single
node
\(v\)
pointed:
\(R_l(T,
v)\)
\(R_r(T,
v)\).
term
\textit{local}
means
that
operation
operate
just
some
finite
fragment
a~tree
with
predefined
size
(e.g.~node
children,
cannot
traverse
whole
tree).
\begin{definition}
\(\enc{R_l(T,
\enc{\tPre(T,
\pointed{\n}
\enc{\tSub(v)}
\enc{\tSuf(T,
v)}\)
\end{definition}
\begin{figure}[H]
\centering
\begin{minipage}{.25\textwidth}\includesvg[scale=0.35]{binary__remy_base}\end{minipage}%
\(\Rightarrow\)
\begin{minipage}{.4\textwidth}\includesvg[scale=0.5]{binary__remy_left}\end{minipage}%
\caption{Visualization
\(\enc{R_l(T,
v)}\)}%
\label{fig:remy_left}
\end{figure}
\begin{definition}
\(\enc{R_r(T,
\enc{\tPre(T,
\enc{\tSub(v)}
\pointed{\n}
\enc{\tSuf(T,
\end{definition}
\begin{figure}[H]
\centering
\begin{minipage}{.25\textwidth}\includesvg[scale=0.35]{binary__remy_base}\end{minipage}%
\(\Rightarrow\)
\begin{minipage}{.4\textwidth}\includesvg[scale=0.5]{binary__remy_right}\end{minipage}%
\caption{Visualization
\(\enc{R_r(T,
v)}\)}%
\label{fig:remy_right}
\end{figure}
take
bijective
interpretation
\((2n
B(n)\),
i.e.~trees
size
\(n\)
with
a~single
node
pointed.
each
such
trees,
\(T\)
create
applying
\(R_l\)
\(R_r\)
pair
\(T',
v\),
where
\(T'\)
\(T\)
with
removed
pointers
\(v\)
a~node
that
pointed
\(T\).
Therefore
generate
\(2(2n
B(n)\)
trees
size
1\).
\todo{rewrite}
only
thing
that's
left
verify
generate
trees
size
with
pointed
leaves.
from
recursion,
know
that
B(n)\)
total
number
trees
with
single
leaf
pointed,
enough
check
generate
duplicate
using
\(R_l\)
\(R_r\).
happen
ways:
\begin{enumerate}
\item
operation
itself
generates
duplicates
\item
different
operations
generate
same
tree.
\end{enumerate}
First
case
also
split
into
subcases.
Without
loss
generality
analyze
just
operations,
\(R_l\).
second
case
symmetric.
\begin{itemize}
\item
some
nodes
\neq
v\),
\(R_l(T,
R_l(T,
v)\).
\(i_u,
i_v\)
indices
respectively
\(\enc{u}\)
\(\enc{v}\)
\(\enc{T}\).
\(\pointed{i}_u,
\pointed{i}_v\)
indices
pointed
node
respectively
\(\enc{R_l(T,
u)}\)
\(\enc{R_l(T,
v)}\).
definition
\(R_l\),
that
\(\pointed{i}_u
\(\pointed{i}_v
1\),
which
implies
that
what
assumed
false.
\item
some
trees
\neq
S\),
\(R_l(T,
R_l(S,
v)\).
\(i_u,
i_v\)
indices
respectively
\(\enc{u}\)
\(\enc{T}\)
\(\enc{v}\)
\(\enc{S}\).
\(\pointed{i}_u,
\pointed{i}_v\)
indices
pointed
node
respectively
\(\enc{R_l(T,
u)}\)
\(\enc{R_l(S,
v)}\).
\(\pointed{i}_u
\neq
\pointed{i}_v\),
this
case
trivially
false,
assume
that
\(\pointed{i}_u
\pointed{i}_v\).
Therefore,
again
from
definition
\(R_l\),
have
that
\(i_u
i_v\).
That
implies
that
\(\enc{\tPre(T,
\enc{\tSub(u)}
\enc{\tSuf(T,
\enc{\tPre(S,
\enc{\tSub(v)}
\enc{\tSuf(S,
which
then
sums
\(\enc{T}
\enc{S}\),
which
assumed
false.
\end{itemize}
second
case
enough
notice
that
\(R_l\)
generates
trees
with
pointed
nodes
being
a~left
child,
\(R_r\)
generates
trees
with
pointed
nodes
being
right
child.
That
immediately
provides
with
conclusion
that
generating
duplicates.
\qed%
\end{interpretation}
\subsection{Unary-binary
trees}%
\label{sub:unary_binary_trees}
Let's
think,
what
would
have
changed
introduce
unary
nodes
binary
case~\cite{motzkin}.
\begin{definition}%
\label{def:unary_binary_tree}
unary-binary
tree
an~ordered
tree
which
node
have
either
children.
\end{definition}
allow
nodes
with
gaps
here,
e.g.~a~binary
node
with
just
child
unary
node
with
children.
will
define
size
number
edges.
Note
that
a~tree
having
\(n\)
edges
exactly
nodes.
easily
derive
generating
function:
\[\gf{U}(z)
z\gf{U}(z)
\gf{U}^2(z)\]
with
a~bit
Maple
magic~\cite{gfun},
immediately
following
recurrence:
\[(n
2)u_{n}
1)u_{n
1)u_{n
2}\]
\[\left\{\begin{array}{rcl}
2)u_{n}
1)u_{n
1)u_{n
\end{array}\right.\]
Definition~\ref{def:unary_binary_tree}
precise,
introduces
a~new
kind
node
that
would
have
take
care
avoid
using
a~trick
make
unary-binary
trees
recall
binary
trees.
change
structure,
just
notation.
\begin{definition}%
\label{def:unary_binary_2}
left-leaning
binary
tree
a~binary
tree
with
following
constraint
added:
a~node
a~right
child,
also
a~left
child.
course
node
with
just
left
child
appear
such
tree.
\end{definition}
bijection
between
unary-binary
trees
left-leaning
binary
ones
very
simple.
just
represent
unary
nodes
nodes
with
just
a~left
child.
other
cases
translate
immediately
themselves.
Please
note
that
this
transformation
preserves
size
tree
(i.e.~number
edges).
next
step
make
binary
trees
full.
Let's
define
virtual
leaves.
\begin{definition}
Virtual
node
an~artificially
defined
node
that
does
affect
structure
definition
(i.e.~they
included
when
counting
number
children
node).
\end{definition}
\begin{definition}
Actual
node
a~node
that
virtual.
\end{definition}
\begin{definition}
virtual
leaf
a~virtual
node
added
node
place
a~non-existing
child.
\end{definition}
have
added
virtual
nodes,
have
added
many
virtual
edges.\todo{notes?}
\begin{figure}[H]
\centering
\includeinlinesvg{.2}{unary_binary__base}%
\(\Rightarrow\)%
\includeinlinesvg{.3}{unary_binary__full}
\caption{Unary-binary
tree
full-binary
tree
transformation}%
\label{fig:unary_binary_transformation}
\end{figure}
Please
note
that
matches
multiplier
\(u_n\)
holonomic
equation.
will
using
\(U(n)\)
describe
sets
trees
corresponding
\(u_n\)
from
holonomic
recurrence.
\((n
U(n)\)
interpreted
trees
size
\(n\)
with
single
virtual
leaf
pointed.
\begin{definition}
that
node
\(v\)
an~virtual-oneling
\(\textiff\)
\(v\)
virtual
siblings.
Note
that
root
oneling
even
parent.
\end{definition}
\begin{definition}
that
node
\(v\)
virtual-twinling
\(\textiff\)
\(v\)
least
virtual
sibling.
\end{definition}
\begin{definition}
\(u\)
parent
\(v\),
that
sibling
\(u\)
an~uncle
\(v\).
\end{definition}
\begin{interpretation}
present
interpretation
bijective
language,
will
have
introduce
several
types
nodes.
\begin{enumerate}
\item
virtual
leaf
being
right
virtual-oneling;
\item
virtual
leaf
being
right
virtual-twinling.
will
divide
this
case
into:
\begin{enumerate}
\item
VrtUrv
which
uncle
a~right
virtual
leaf;
\item
VrtUra
which
uncle
a~right
actual
node;
\item
VrtUla
which
uncle
a~left
actual
node.
\end{enumerate}
\item
virtual
leaf
left
virtual-twinling.
Note
that
from
definition~\ref{def:unary_binary_2},
left
virtual
leave
cannot
have
a~sibling
being
an~actual
node.
divide
also
this
case
into:
\begin{enumerate}
\item
VltUrv
which
uncle
a~right
virtual
leaf;
\item
VltUra
which
uncle
a~right
actual
node;
\item
VltUla
which
uncle
a~left
actual
node;
\end{enumerate}
\item
actual
node.
\end{enumerate}
Note
that
covers
possible
cases
nodes
cases
mutually
disjoint.
There
such
thing
VrtUlv,
VltUlv
Definition~\ref{def:unary_binary_2}.
need
show
transformations
from
smaller
cases,
i.e.~pointed
trees
from
\(U(n-1)\)
\(U(n-2)\)
\(U(n)\).
Let's
start
from
\(U(n-1)\).
multiplier
\(2n
1\).
suggests
that
point
node,
a~tree
having
actual
edges,
have
\(n\)
actual
virtual
nodes.
case
\(U(n-2)\),
multiplier
\(3(n-1)\),
which
suggests
that
should
perform
\(3\)
distinct
types
transformations
trees
with
a~pointed
actual
node.
table
below
show
transformations
that
applied
trees
from
\(U(n-1)\)
\(U(n-2)\)
order
achieve
trees
from
\(U(n)\).
mark
pointed
node
with
\(\pointed{}\).
find
case
name
bottom
left
corners
cells.
\begin{center}
\begin{longtable}{|
\hline
\(U(n-2)\)
\(U(n-1)\)
\(U(n)\)\\
\hline
\includesvg[scale=0.4]{unary_binary__1si}
\(\Rightarrow\)&
\includesvg[scale=0.4]{unary_binary__0fid}
\hline
\includesvg[scale=0.4]{unary_binary__1fjg}
\(\Rightarrow\)&
VrtUrv
\includesvg[scale=0.4]{unary_binary__0fjdOgf}
\hline
\includesvg[scale=0.4]{unary_binary__2i}
\(\Rightarrow\)&
VrtUra
\includesvg[scale=0.4]{unary_binary__0fjdOdi}
\hline
\includesvg[scale=0.4]{unary_binary__1fid}
\(\Rightarrow\)&
VrtUla
\includesvg[scale=0.4]{unary_binary__0fjdOgi}
\hline
\includesvg[scale=0.4]{unary_binary__1fjd}
\(\Rightarrow\)&
VltUrv
\includesvg[scale=0.4]{unary_binary__0fjgOdf}
\hline
\includesvg[scale=0.4]{unary_binary__2i}
\(\Rightarrow\)&
VltUra
\includesvg[scale=0.4]{unary_binary__0fjgOdi}
\hline
\includesvg[scale=0.4]{unary_binary__2i}
\(\Rightarrow\)&
VltUla
\includesvg[scale=0.4]{unary_binary__0fjgOgi}
\hline
\end{longtable}
\end{center}
see,
have
satisfied
cases
trees
from
\(U(n-2)\),
\(U(n-1)\)
\(U(n)\)
with
repetitions,
which
concludes
construction.
\qed%
\end{interpretation}
\subsection{Schr
trees}%
\label{sub:schr
der_trees}
next
case
will
show
case
Schr
trees~\cite{schroder}.
\begin{definition}%
\label{def:schroder_tree}
Schr
tree
a~tree
with
unary
nodes.
Empty
children
allowed
(e.g.~binary
node
with
just
child).
\end{definition}
Simply
speaking,
nodes
have
zero
strictly
more
than
child.
\begin{figure}[H]
\centering
\includesvg[scale=0.4]{schroder__example_1}
\includesvg[scale=0.4]{schroder__example_2}
\includesvg[scale=0.4]{schroder__example_3}
\includesvg[scale=0.4]{schroder__example_4}
\(\ldots\)
\caption{Possible
cases
Schr
tree
nodes}%
\label{fig:schroder_trees}
\end{figure}
This
definition
precise,
difficult
implement
a~structural
recursion.
Let's
define
binary
structure
that
will
allow
encode
Schr
trees.
\begin{definition}%
\label{def:well_weighted}
well-weighted
full
binary
tree
a~weighted
tree
such
that:
\begin{itemize}
\item
leaves
unweighted;
\item
internal
nodes
have
weight
either
\(1\)
\(2\);
\item
an~internal
node
weight
then
right
child
a~leaf.
\end{itemize}
\end{definition}
Let's
represent
node
\(v\)
with
a~weight
\(n\)
\(v\weighted{n}\).
easily
define
bijection
\(\Phi\)
between
models
from
Definition~\ref{def:schroder_tree}
and~\ref{def:well_weighted}
using
pre-order
notation:
\[\Phi(T)
\left\{\begin{array}{lcl}
\n\weighted{1}\;
T_1\;
\n\;
T_1\;
T_2\\
\n\weighted{2}\;
T_1\;
\Phi(\n\;
\ldots
T_n)
\n\;
T_1\;
\ldots
\end{array}\right.\]
\todo{image}
Let's
define
size
tree
a~number
leaves.
leaves
translated
leaves
internal
nodes
internal
nodes,
bijection
\(\Phi\)
size-preserving.
generating
function
equation
then:
\[\left\{\begin{array}{rcl}
\gf{T}(z)
\gf{T}_1(z)
\gf{T}_2(z)
\gf{T}_1(z)
\gf{T}^2(z)\\
\gf{T}_2(z)
\gf{T}(z)(\gf{T}_1(z)
\gf{T}_2(z))
\end{array}\right.\]
\(\gf{T}_1\)
\(\gf{T}_1\)
generating
functions
trees
rooted
nodes
weight
\(1\)
\(2\)
respectively.
\(\gf{T}\)
generating
function
whole
well-weighted
full
binary
tree.
able
Maple
generate
corresponding
recurrence,
need
transform
this
system
equations
a~single
one.
eliminate
\(\gf{T}_1(z)\)
first.
\[\left\{\begin{array}{rcl}
\gf{T}(z)
\gf{T}^2(z)
\gf{T}_2(z)
\gf{T}_2(z)
\gf{T}(z)(\gf{T}^2(z)
\gf{T}_2(z))
\end{array}\right.\]
\[\left\{\begin{array}{rcl}
\gf{T}(z)
\gf{T}^2(z)
\gf{T}_2(z)
\gf{T}_2(z)(1
\gf{T}(z))
\gf{T}^3(z)
\end{array}\right.\]
cannot
division
\(\gf{T}_2(z)\),
let's
multiply
first
equation
\gf{T}(z)\).
\[\gf{T}(z)(1
\gf{T}(z))
\gf{T}^2(z)(1
\gf{T}(z))
\gf{T}^3(z)
\gf{T}(z))\]
actually
used
generate
holonomic
recurrence.
\begin{lstlisting}
with(gfun):
RootOf(T*(1
T^2*(1
z*(1
RootOf(2
algfuntoalgeq(%,
T(z));
algeqtodiffeq(%,
T(z));
T(z)
T(z)|,
T(0)
RootOf(2
_Z)}
diffeqtorec(%,
T(z),
T(n));
T(n)
...}
subs(n
{(-2
T(n)
...}
\end{lstlisting}
also
move
\(t_n\)
other
side,
i.e.:
\[\left\{\begin{array}{rcl}
t_{n
t_{n
\end{array}\right.\]
This
seem
counterintuitive,
default
want
describe
generate
larger
cases
from
smaller
ones,
will
make
interpretation
simpler.
Let's
translate
recurrence
bijective
language
then.
\begin{itemize}
\item
\((2
T(n)\)
describes
well-weighted
binary
trees
size
\(n\)
(i.e.~with
\(n\)
leaves)
with
some
node
pointed
(internal
leaf),
\item
\((n
1)\)
describes
well-weighted
binary
trees
size
with
some
leaf
pointed,
\item
\((n
1)\)
describes
well-weighted
binary
trees
size
with
some
internal
node
pointed.
\end{itemize}
will
show
bijection
between
sides
recursion.
will
transform
each
tree
from
\((2
T(n)\)
three
ways
order
achieve
trees
from
\((n
1)\).
will
some
extra
ones
which
well-weighted,
will
deal
with
them
a~minute.
Let's
define
three
transformations,
\(L_1\),
\(L_2\),
\(R_1\)
that
transform
tree
with
a~pointed
node
\(s\)
into
bigger
tree,
follows.
dashed
edges
\begin{minipage}{1.5em}
\includesvg[width=\textwidth]{intro__dashed_edge}
\end{minipage}
depict
edges
that
exist
(i.e.~when
node
have
parent
child,
does
have
to).
Whenever
solid
edge,
expect
this
edge
actually
exist.
\begin{center}
\includeinlinescaledsvg{.16}{.5}{schroder__lr_base}%
\(\xRightarrow{L_1}\)%
\includeinlinescaledsvg{.16}{.5}{schroder__l1}%
\hspace{.1\textwidth}%
\includeinlinescaledsvg{.16}{.5}{schroder__lr_base}%
\(\xRightarrow{L_2}\)%
\includeinlinescaledsvg{.16}{.5}{schroder__l2}%
\includeinlinescaledsvg{.16}{.5}{schroder__lr_base}%
\(\xRightarrow{R_1}\)%
\includeinlinescaledsvg{.16}{.5}{schroder__r1}%
\end{center}
that
trees
generated
\(L_1\)
\(R_1\)
always
well-weighted.
problem
appears
when
applying
\(L_2\)
when
\(s\)
a~leaf.
When
\(s\)
a~leaf,
will
look
parent.
fall
into
following
cases,
where
\(t'\)
tree
\(t''\)
cannot
a~leaf.
\begin{center}
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.5]{schroder__case_a}\\
Case
\end{center}
\end{minipage}%
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.5]{schroder__case_b}\\
Case
\end{center}
\end{minipage}%
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.5]{schroder__case_c}\\
Case
\end{center}
\end{minipage}%
\end{center}
When
applying
\(L_2\)
achieve
following
cases
respectively:
\begin{center}
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.45]{schroder__case_a_l}\\
Case
\end{center}
\end{minipage}%
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.45]{schroder__case_b_l}\\
Case
\end{center}
\end{minipage}%
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.45]{schroder__case_c_l}\\
Case
\end{center}
\end{minipage}%
\end{center}
case
1.~and
2.~we
just
swap
labels
follows:
\begin{center}
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.45]{schroder__case_a_l_fixed}\\
Case
\end{center}
\end{minipage}%
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.45]{schroder__case_b_l_fixed}\\
Case
\end{center}
\end{minipage}%
\end{center}
easy
show
that
constructs
bijection
between
\((n
1)\)
subset
\((2
T(n)\)
with
\(L_1\),
\(L_2\)
\(R_1\)
applied,
falling
into
case
will
show
that
a~moment.
achieve
trees
from
\((n
1)\),
simply
take
trees
from
case
3.~and
replace
whole
subtree
with
subtree
\(t''\)
with
root
pointed.
this
way,
will
lose
\(2\)
leaves
obtain
each
tree
from
\((n
1)\):
\begin{center}
\begin{minipage}[t]{.3\textwidth}
\begin{center}
\includesvg[scale=0.45]{schroder__case_c_l_fixed}\\
Case
\end{center}
\end{minipage}%
\end{center}
bijection,
just
draw
possible
cases:
\begin{center}
\begin{longtable}{|
\hline
\(\Rightarrow\)&
\(R_1\)
\(L_1\)
\(L_2\)
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__21}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__23}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__22}
\begin{minipage}{.23\textwidth}
\begin{center}
\includeinlinescaledsvg{1}{.35}{schroder__proof__24}
\(\Downarrow\)
\includeinlinescaledsvg{1}{.35}{schroder__proof__24b}
\end{center}
\end{minipage}
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__11}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__13}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__12}
\begin{minipage}{.23\textwidth}
\begin{center}
\includeinlinescaledsvg{1}{.35}{schroder__proof__14}
\(\Downarrow\)
\includeinlinescaledsvg{1}{.35}{schroder__proof__14b}
\end{center}
\end{minipage}
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__31}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__33}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__32}
\begin{minipage}{.23\textwidth}
\begin{center}
\includeinlinescaledsvg{1}{.35}{schroder__proof__34}
\(\Downarrow\)
\includeinlinescaledsvg{1}{.35}{schroder__proof__34b}
\end{center}
\end{minipage}
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__51}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__53}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__52}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__54}
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__41}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__43}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__42}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__44}
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__61}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__63}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__62}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__64}
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__71}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__73}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__72}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__74}
\hline
\includeinlinescaledsvg{.23}{.35}{schroder__proof__81}
\(\Rightarrow\)&
\includeinlinescaledsvg{.23}{.35}{schroder__proof__83}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__82}
\includeinlinescaledsvg{.23}{.35}{schroder__proof__84}
\hline
\end{longtable}
\end{center}
left
column
possibilities
selecting
\(s\)
from
a~tree
size
\(n\).
\(R_1\),
\(L_1\)
\(L_2\)
columns
show
they
then
transformed.
covers
possible
cases
selecting
leaf
from
a~tree
size
selecting
an~internal
node
from
a~tree
size
1\).
\section{Approaches}%
\label{sec:approaches}
could
examples
above,
most
solutions
based
simple
analysis
number
leaves,
internal
nodes
some
their
special
types.
this
section,
will
gather
some
methods
that
helpful
when
trying
analyze
problem
interpreting
combinatorially
some
holonomic
recurrences.
\subsection{Defining
size
carefully}%
\label{sub:defining_the_size_carefully}
First
thing
done
define
size
carefully.
have
standard
choices
specifying
size
trees:
\begin{itemize}
\item
counting
existing
nodes,
\item
counting
internal
nodes,
\item
counting
leaves,
\item
counting
virtual
leaves
(i.e.~virtual
nodes
being
children
actual
leaves),
\item
counting
edges.
\end{itemize}
seem
counterintuitive
first
that
this
changes
anything
crucial,
definition
changes
shape
holonomic
recurrence.
Sometimes
changing
definition
drastically
reduce
number
cases
have
consider.
There
most
common
symptoms
indicating
that
want
choose
different
method
counting
size:
\begin{itemize}
\item
empty
classes
objects,
e.g.~if
analyze
problem
full
binary
trees
define
size
number
existing
nodes,
cannot
generate
tree
even
size,
therefore
every
second
class
empty;
\item
want
join
trees
using
newly
created
node,
which
will
become
root
object
equations
getting
complicated.
example
define
size
number
internal
nodes,
such
catenation
creates
a~tree
size
being
sizes
components
increased
\(1\).
This
\(+1\)
drastically
clutter
holonomic
recurrence.
defined
size
number
leaves,
size
object
would
just
a~simple
sizes
smaller
trees.
\end{itemize}
\subsection{Tree
binarization}%
\label{sub:tree_binarization}
describe
some
structure
tempted
multiple
kinds
nodes,
e.g.~unary
binary
nodes.
Having
multiple
kinds
nodes
cause
problems,
both
creating
holonomic
recurrence
finding
interpretation,
have
keep
track
they
transform.
most
common
trees
binary
ones,
worth
an~effort
find
some
structure
based
binary
trees
that
represent
original
structure
(see
Section~\ref{sub:unary_binary_trees}).
\subsection{Custom
weights
assignment}%
\label{sub:weights_variablization}
Most
time
operating
trees
with
some
nodes
weight
\(0\)
some
weight
\(1\).
well
make
them
variable
assign
some
other
values
(e.g.~small
prime
numbers).
\todo{rewrite
unary-binary}
Section~\ref{sub:lambda_terms}
will
define
trees
lambda
terms.
would
assign
following
weights
nodes:
\[\begin{array}{rcl}
a~&:&
\end{array}\]
would
significantly
smaller
classes
\begin{longtable}{|
\hline
Size
Trees
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_002_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_005_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_007_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_008_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_010_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_011_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_011_000001}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_012_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_014_000002}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_015_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_016_000003}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000003}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_017_000004}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_018_000000}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000003}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000004}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000005}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_019_000006}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000003}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000004}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000005}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000006}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_020_000007}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000003}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000004}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000005}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_021_000006}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000003}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000004}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000005}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000006}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000007}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000008}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000009}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_022_000010}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000003}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000004}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000005}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000006}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000007}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000008}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000009}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000010}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000011}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_023_000012}
\end{minipage}
\\\hline
\begin{minipage}{.9\textwidth}\centering
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000000}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000001}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000002}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000003}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000004}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000005}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000006}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000007}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000008}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000009}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000010}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000011}
\includeinlinescaledsvg{.19}{.5}{lambda__2357__lambda2357_024_000012}
\end{minipage}
\\\hline
\end{longtable}
This
method
gives
some
suggestion
which
kind
nodes
modified
operation
Another
benefit
this
method
decreasing
cardinalities
sets
objects
given
size,
have
less
objects
look
Unfortunately,
decreasing
cardinalities
classes
increases
number
sets
need
analyze
a~full
interpretation.
\subsection{Inductive
translation}%
\label{sub:inductive_translation}
Another
method
that
help
finding
interpretation
inductive
translation~\cite{doron}.
method
based
idea
that
most
time
there
an~easy
find
some
natural
recurrence
(not
necessarily
holonomic)
that
simple
interpretation
bijective
language.
case
binary
trees
with
size
defined
number
leaves,
define
recurrences:
\[\text{Holonomic
recurrence}
b_{n}
b_{n
1}\]
\[\text{Non-linear
recurrence}
b_{n}
\sum_{i=1}^{n
b_{i}
b_{n
i}\]
non-linear
a~very
simple
interpretation.
take
smaller
trees
join
them
using
newly
created
common
root.
multiply
both
sides
non-linear
recurrence
\(n\)
break
i)\)
similar
sums
b_{n}
\sum_{i=1}^{n
b_{i}
b_{n
\sum_{i=1}^{n
b_{n
b_{i}\]
Using
inductive
hypothesis,
i.e.~holonomic
recurrence
moving
problematic
boundary
cases
from
sums
this
case
\(b_{1}\)
needs
analyzed
separately,
define
binary
trees
with
leaves),
right
side
\(b_{n
1}\)
prove
that
holonomic
recurrence
using
non-linear
one.
only
part
that
left
translate
this
inductive
proof
bijective
language,
which
such
a~simple
case
binary
trees
quite
simple,
especially
seen
solution
once.
method
itself
proven
helpful
order
divide
problem
into
smaller
parts
find
some
corner
cases.
Unfortunately,
does
give
immediate
interpretation
applying
inductive
step.
\todo{fill
gaps}
\todo{add
reconstruction
images}
\section{Brutal
iterative
approach}%
\label{sec:brutal_iterative_approach}
manual
methods
have
failed
problem
still
complex
interpret
hand,
a~computer
comes
handy.
inspiration
main
field
interest
analysis
trees
lambda
terms
unary
Bruijn
notation,
will
introduce
them
them
an~example
describe
method.
\subsection{Lambda
terms}%
\label{sub:lambda_terms}
Lambda
calculus
formal
system
that
allows
expressing
computable
functions
introduced
Alonzo
Church.
widely
used
computer
science
mathematics
study
functions
their
properties.
countable
variables
given.
\begin{definition}
lambda
terms
\(\Lambda\)
defined
recursively:
\begin{itemize}
\item
\(x\)
a~variable,
then
\Lambda\)
\item
\(M,
\Lambda\),
then
\((M
\Lambda\)
interpreted
application
function
\(M\)
an~argument
\(N\))
\item
\(x\)
a~variable
\Lambda\),
then
\((\lambda
\Lambda\)
interpreted
an~abstraction,
i.e.~creating
a~function
with
an~argument
\(x\)
binding
each
occurrence
\(x\)
\(M\)
this
argument.
that
variable
\(x\)
abstracted
this
lambda-abstraction)
\end{itemize}
\end{definition}
This
definition
resembles
tree-based
structure
lambda
terms,
where:
\begin{itemize}
\item
lambda
abstraction
represented
unary
node
holding
name
lambda-abstracted
variable;
\item
application
represented
binary
node;
\item
variable
represented
leaf
holding
name
variable.
\end{itemize}
\begin{figure}[H]
\centering
\includesvg[scale=.7]{lambda__tree_structure__example_custom}
\caption{Tree
representation
term
\(\lambda
(\lambda
y.x)
(\lambda
y.y)\).}%
\label{fig:lambda_tree_example}
\end{figure}
have
used
dashed
arrows
point
lambda-abstraction
binding
particular
variables.
also
possible
that
variable
unbound,
i.e.~there
lambda-abstraction
that
abstracts
variable.
perfectly
fine
with
that.
definition
using
named
variables
quite
popular,
introduces
several
problems.
them
a~problem
potential
collision
lambda-abstracted
variable
names
difficulty
finding
which
lambda
abstraction
variable
bound
even
a~free
variable,
i.e.~not
bound).
address
that,
Bruijn
indices.
\begin{definition}
lambda
terms
\(\LambdadB\)
defined
recursively:
\begin{itemize}
\item
\N\),
then
\LambdadB\)
(\(n\)
a~variable
bound
lambda
abstraction
\(n\)
levels
above,
i.e.~if
traverse
tree
lambda
term
upwards,
have
ignore
\(n\)
lambda-abstraction
nodes
\((n+1)\)-st
binding
variable.
would
have
beyond
root
tree,
that
variable
free,
i.e.~not
bound)
\item
\(M,
\LambdadB\),
then
\((M
\LambdadB\)
(application)
\item
\LambdadB\),
then
\((\lambda
\LambdadB\)
(abstraction)
\end{itemize}
\end{definition}
see,
managed
eliminate
name-based
variables.
also
easily
check
a~given
variable
bound
checking
depth.
\begin{example}
\(\lambda
x.\lambda
y.x\)
equivalent
\(\lambda
\lambda
\end{example}
\begin{example}
\(\lambda
(\lambda
y.x)
(\lambda
y.y)\)
equivalent
\(\lambda
(\lambda
(\lambda
0)\)
\end{example}
define
tree
representation
terms
from
\(\LambdadB\).
order
encode
natural
numbers,
unary
notation.
This
allows
connect
size
tree
Bruijn
index
values.
\begin{definition}
Translation
from
lambda
terms
Bruijn
notation
binary
trees
\(\Phi\)
defined
follows:
\begin{itemize}
\item
\(\Phi(0)
\n\;
\no\;
\no\)
\item
\(\Phi(n)
\n\;
\no\;
\Phi(n
1)\)
(this
node
acts
successor
unary
notation,
i.e.~function
incrementing
natural
number
\(1\))
\item
\(\Phi(\lambda
\n\;
\Phi(M)\;
\no\)
\item
\(\Phi(M
\n\;
\Phi(M)\;
\Phi(N)\)
\end{itemize}
\end{definition}
\begin{figure}[H]
\centering
\includesvg[scale=.7]{lambda__tree_structure__deBruijn_001_custom}
\caption{Tree
representation
term
\(\lambda
(\lambda
(\lambda
0)\).}%
\label{fig:lambda_tree_example_2}
\end{figure}
green
edges
express
non-existing
child
node.
Note
that
order
exact
value
variable
take
look
leaf
with
successor
nodes
above
simplify
interpretation,
introduce
several
kinds
nodes:
\(o\),
\(s\),
\(l\)
\(a\).
They
change
structure,
make
reading
a~bit
easier:
\begin{definition}
\(o\)
a~leaf.
\end{definition}
\begin{definition}
\(s\)
a~node
with
only
right
child.
\end{definition}
\begin{definition}
\(l\)
a~node
with
only
left
child.
\end{definition}
\begin{definition}
\(a\)
a~node
with
both
children.
\end{definition}
This
leads
following
interpretation
\(\Phi\):
\begin{itemize}
\item
\(\Phi(0)
\no\;
\no\)
\item
\(\Phi(n)
\no\;
\Phi(n
1)\)
\item
\(\Phi(\lambda
\Phi(M)\;
\no\)
\item
\(\Phi(M
\Phi(M)\;
\Phi(N)\)
\end{itemize}
\begin{figure}[H]
\centering
\includesvg[scale=.7]{lambda__tree_structure__deBruijn_002_custom}
\caption{Tree
representation
term
\(\lambda
(\lambda
(\lambda
0)\)
with
node
kinds.}%
\label{fig:lambda_tree_example_3}
\end{figure}
note
that
every
tree
binary
tree
representation,
every
binary
tree
represents
a~valid
term.
\begin{example}
\(\n\;
\no\;
\n\;
\n\;
\no\;
\no\;
\no\)
does
represent
a~valid
tree,
a~valid
lambda
term.
that,
take
a~look
this
tree
with
node
kinds
used:
\begin{figure}[H]
\centering
\includesvg[scale=.7]{lambda__tree_structure__deBruijn_invalid}
\caption{Visualization
tree
\(\n\;
\no\;
\n\;
\n\;
\no\;
\no\;
\no\)
with
node
kinds.}%
\label{fig:lambda_tree_invalid}
\end{figure}
\(s\)
represents
successor,
applied
only
\N\),
applied
lambda-abstracted
term.
\end{example}
\subsection{Enhanced
holonomic
recurrence}%
\label{sub:enhanced_holonomic_reccurence}
have
structure
defined,
let's
create
generating
function
that
will
keep
track
more
than
just
number
nodes,
also
counts
number
each
kind
node
tree.
generating
function
\(\gf{T}(z,
s)\)
will
parameterized
then
using
following
arguments:
\begin{itemize}
\item
\(z\)
marking
actual
nodes
\item
\(o\)
marking
variable
nodes
\item
\(l\)
marking
lambda
abstraction
nodes
\item
\(a\)
marking
application
nodes
\item
\(s\)
marking
successors
variable
nodes
\end{itemize}
order
make
image
cleaner,
will
drop
arguments
generating
functions,
i.e.~\(\gf{T}
\gf{T}(z,
s)\).
\begin{center}
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\(\gf{T}\)\\
\includesvg[scale=0.5]{lambda__def__1}%
\end{center}
\end{minipage}%
\begin{minipage}[t]{.05\textwidth}
\begin{center}
\(=\)\\
\end{center}
\end{minipage}%
\begin{minipage}[t]{.2\textwidth}
\begin{center}
a~\gf{T}^2\)\\
\includesvg[scale=0.5]{lambda__def__2}%
\end{center}
\end{minipage}%
\begin{minipage}[t]{.05\textwidth}
\begin{center}
\(+\)\\
\end{center}
\end{minipage}%
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\gf{T}\)\\
\includesvg[scale=0.5]{lambda__def__3}%
\end{center}
\end{minipage}%
\begin{minipage}[t]{.05\textwidth}
\begin{center}
\(+\)\\
\end{center}
\end{minipage}%
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\(\gf{S}\)\\
\includesvg[scale=0.5]{lambda__def__4}%
\end{center}
\end{minipage}%
\end{center}
where
\(V\)
represents
part
tree
being
variable
(i.e.~\(o\)
node,
potentially
with
some
\(s\)
successor
nodes
applied):
\begin{center}
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\(\gf{V}\)\\
\includesvg[scale=0.5]{lambda__def__5}%
\end{center}
\end{minipage}%
\begin{minipage}[t]{.05\textwidth}
\begin{center}
\(=\)\\
\end{center}
\end{minipage}%
\begin{minipage}[t]{.2\textwidth}
\begin{center}
\gf{V}\)\\
\includesvg[scale=0.5]{lambda__def__4}%
\end{center}
\end{minipage}%
\begin{minipage}[t]{.05\textwidth}
\begin{center}
\(+\)\\
\end{center}
\end{minipage}%
\begin{minipage}[t]{.2\textwidth}
\begin{center}
o\)\\
\includesvg[scale=0.5]{lambda__def__6}%
\end{center}
\end{minipage}%
\end{center}
After
solving
equation
\(\gf{V}\),
get:
\[\gf{T}
a~\gf{T}^2
\gf{T}
\frac{z
o}{1
s}\]
treat
\(z\)
only
variable
make
\(o\),
\(l\),
\(a\),
\(s\)
constants,
a~little
Maple
magic~\cite{gfun}
achieve
following
holonomic
recurrence.
\[\begin{array}{rl}
t_{n
4}\\
s^2)
t_{n
3}\\
((-4
s^2)
t_{n
2}\\
((-2
t_{n
1}\\
t_{n}
\end{array}.\]
Terms
\(o\),
\(l\),
\(a\),
\(s\)
appearing
holonomic
recurrence
interpreted
list
kinds
nodes
need
extend
smaller
tree
into
bigger
one.
\begin{example}
Let's
consider
summands,
\((2n
t_{n
3}\).
interpret
extending
trees
size
\((n
3)\).
total
want
have
\((2n
t_{n
3}\)
them
each
them
should
have
some
node
pointed
allow
duplicates).
extend
tree
need
exactly
\(l\)
node
\(s\)
nodes.
\end{example}
forget
about
kinds
nodes,
following
recurrence:
\[\begin{array}{rl}
t_{n
4}\\
t_{n
3}\\
t_{n
2}\\
t_{n
1}\\
t_{n}
\end{array}.\]
notice
that
some
summands
have
become
oversimplified.
example
\(((4
s^2)
t_{n
3}\)
become
\(t_{n-3}\),
which
could
interpreted
simply
trees
size
without
pointing.
\subsection{Transformator
framework}%
\label{sub:the_framework}
also
created
a~framework~\cite{transformator},
called
Transformator,
that
help
visualize
work.
operates
binary
trees
based
idea
that
every
transformation
expressed
bijective
language
local,
i.e.~transforms
some
node
finite
number
surrounding
nodes.
show
idea
such
transformations,
let's
define
transformation
context
with
holes.
context
specifies
shape
fragment
tree.
have
holes
that
specify
whole
subtree.
also
specify
whether
root
context
parent
left
right
child
parent.
\begin{example}
want
modify
node
being
right
child
parent.
care
what
below
that
node
(i.e.~if
that
leaf
children).
want
node
which
original
left
child.
want
node
have
right
child.
Additionally
want
swap
potential
children
original
node.
define
following
transformation:
\begin{center}
\includeinlinescaledsvg{.4}{.7}{lambda__contexts__def_001}%
\(\Rightarrow\)
\includeinlinescaledsvg{.4}{.7}{lambda__contexts__def_002}%
\end{center}
\end{example}
marked
node
being
transformed
clarify
picture.
support
following
starting
contexts
transformations:
\begin{itemize}
\item
node
a~virtual
leaf
(each
tree
with
\(n\)
actual
nodes
exactly
\((n
1)\)
places
where
such
contex
apply):\\
\includeinlinescaledsvg{1}{.7}{lambda__contexts__type_001}%
\item
node
an~actual
node
(tree
with
\(n\)
actual
nodes
excatly
\(n\)
places
where
such
context
apply):\\
\includeinlinescaledsvg{1}{.7}{lambda__contexts__type_002}%
\item
node
a~root
(each
tree
exactly
\(1\)
place
where
such
context
apply):\\
\includeinlinescaledsvg{1}{.7}{lambda__contexts__type_003}%
\item
node
parent
left,
i.e.~is
right
child
parent:\\
\includeinlinescaledsvg{1}{.7}{lambda__contexts__type_004}%
\item
node
parent
right,
i.e.~is
left
child
parent:\\
\includeinlinescaledsvg{1}{.7}{lambda__contexts__type_005}%
\end{itemize}
latest
introduced
order
make
analysis
simpler,
have
immediate
interpretation
world
holonomic
recurrences.
However,
them
both,
sums
nodes
except
root
root
neither
left
right
child),
total
there
\((n
1)\)
places
where
such
pair
contexts
apply.
target
transformation
context
preserving
holes.
This
allows
specify
number
nodes
added
transformation.
\subsection{Transformation
classes}%
\label{sub:transformation_classes}
will
operating
transformation
classes,
sections
parts.
Let's
define
them:
\begin{definition}
Class
\(T_i\)
defined
a~set
transformations
trees
size
\((n
i)\)
into
trees
size
\(n\).
\end{definition}
\begin{definition}
Section
\(T_{i,j}\)
defined
a~subset
\(T_i\)
adding
a~specific
nodes.
assign
\(j\)
according
lexicographical
order
lexicographically
sorted
node
types.
\end{definition}
\begin{definition}
Part
\(T_{i,j,k}\)
defined
a~single
transformation
section
\(T_{i,j}\).
\(k\)
assigned
according
order
discovering
transformation.
\end{definition}
order
make
interpretation
more
human
readable,
will
using
local
notation:
\begin{definition}
context
\(T_i\),
\(k\)
defined
\((n
i)\).
\end{definition}
\begin{definition}
context
\(T_i\),
\(C_k\)
defined
\(T(n
i)\),
i.e.~number
tree
transformations
from
\(T_i\)
working
\end{definition}
\begin{definition}
Section
equation
\(E_{i,
j}\)
an~equation
defined
context
\(T_i\)
that
evaluates
a~total
number
trees
that
should
generated
transformations
from
\(T_{i,
j}\).
\end{definition}
\begin{definition}
Section
expression
\(S_{i,
j}\)
a~pair
section
equations
a~set
kinds
nodes
transformation
introduces.
\end{definition}
problem
interpreting
trees
lambda
terms
define
following
section
expressions:
\[\begin{array}{rccrlc}
S_{0,0}
C_k,&
\emptyset
&)\\
S_{1,0}
C_k,&
\{l\}
&)\\
S_{1,1}
C_k,&
\{s\}
&)\\
S_{2,0}
C_k,&
\{ao\}
&)\\
S_{2,1}
C_k,&
\{ll\}
&)\\
S_{2,2}
C_k,&
\{ls\}
&)\\
S_{2,3}
C_k,&
\{ss\}
&)\\
S_{3,0}
C_k,&
\{aos\}
&)\\
S_{3,1}
C_k,&
\{lls\}
&)\\
S_{3,2}
C_k,&
\{lss\}
&)\\
S_{4,0}
C_k,&
\{llss\}
&)\\
\end{array}\]
Using
context-based
variables
makes
equation
simpler
interpret,
immediately
relation
between
\(k\)
multiplier.
\subsection{Iteration}%
\label{sub:iteration}
want
make
work
kind
organized,
going
divide
process
finding
interpretation
into
iterations.
Each
iteration
should
a~small
step
into
direction
solving
original
problem.
going
generate
kinds
trees:
positive
negative
ones.
When
computing
total
number
trees
given
size,
count
positive
trees
\(1\)
negative
\(-1\).
goal
generate
\(E_{i,
j}\)
trees
each
section
\(T_{i,
j}\).
brains
like
small
examples,
will
consider
small
3\).
This
will
cause
some
classes
empty
beginning,
it's
That's
less
trees
look
\begin{lstlisting}
Classes
stats
0,0:
1,0:
1,1:
2,0:
[ao]
2,1:
[ll]
2,2:
[ls]
2,3:
[ss]
3,0:
[aos]
3,1:
[lls]
3,2:
[lss]
4,0:
[llss]
\end{lstlisting}
This
statistic
tells
each
section,
many
trees
have
been
generated
expected
total
number
trees
that
section.
\verb|[x]|
means
that
generated
enough
trees
such
a~section.
start
with
interpreting
\(E_{0,0}
C_k\).
From
statistics
above,
that
should
generate
\(16\)
trees.
\((k
1)\)
suggests
pointing
a~virtual
leaf.
Let's
\begin{lstlisting}
c.define_class(0)
c.define_section(0)
c.append_r_class_subtree_visitor(1,
define
positive
trees
i.e.
that
count
lambda
kind,
left,
right:
None
kind[0]
None
else
ignore
actual
nodes
[kind
("*",
left
right
each
virtual
node
point
\end{lstlisting}
\begin{lstlisting}
define
0,0:
Classes
stats
0,0:
1,0:
1,1:
2,0:
[ao]
2,1:
[ll]
2,2:
[ls]
2,3:
[ss]
3,0:
[aos]
3,1:
[lls]
3,2:
[lss]
4,0:
[llss]
Diff
stats
0,0:
\end{lstlisting}
framework
informs
that
have
generated
trees
section
\(0,0\)
3\).
also
provide
with
visualization
trees
have
generated.
example:
\includeinlinesvg{.19}{lambda__trees_00__4_base}%
\(\Rightarrow\)
\includeinlinesvg{.19}{lambda__trees_00__4}%
\includeinlinesvg{.19}{lambda__trees_00__5}%
\includeinlinesvg{.19}{lambda__trees_00__6}%
\includeinlinesvg{.19}{lambda__trees_00__7}%
take
a~look
more
examples
from
class
\(0\),
start
seeing
some
patterns:
(1)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__2}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__3}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__7}%
\end{center}\end{minipage}
(2)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__4}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__12}%
\includeinlinescaledsvg{.33}{.4}{lambda__trees_00__13}%
\end{center}\end{minipage}
(3)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__0}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__1}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__5}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__6}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__14}%
\includeinlinescaledsvg{.16}{.4}{lambda__trees_00__15}%
\end{center}\end{minipage}
(4)%
\begin{minipage}{.98\textwidth}\begin{center}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__8}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__9}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__10}%
\includeinlinescaledsvg{.25}{.4}{lambda__trees_00__11}%
\end{center}\end{minipage}
order
a~bit
suggestive.
Section
\(1,0\)
adds
a~single
\(l\)
node,
whereas
section
\(1,1\)
adds
a~single
\(s\)
node.
actually
suggests
generate
first
second
line
trees
above.
first
simple.
Let's
\(l\)
node
with
pointed
right
virtual
leaf
above
each
actual
node:
\begin{lstlisting}
c.define_class(1)
c.define_section(0)
c.append_r_class_subtree_visitor(-1,
negative
node
lambda
kind,
left,
right:
None
kind[0]
None
else
ignore
virtual
nodes
["l",
kind]
left
right
[(None,
"*")]
each
actual
node
node
with
right
virtual
node
pointed
parent
\end{lstlisting}
\todo{Repeat
natural
language}
creates
following
trees:
\todo{Mark
transformed
nodes}
\includeinlinesvg{.24}{lambda__trees_100__0_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__0}%
\includeinlinesvg{.24}{lambda__trees_100__1_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__1}%
\includeinlinesvg{.24}{lambda__trees_100__2_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__2}%
\includeinlinesvg{.24}{lambda__trees_100__3_base}\(\Rightarrow\)\includeinlinesvg{.24}{lambda__trees_100__3}%
addresses
cases
from
first
line,
also
introduces
an~incorrect
lambda
tree
which
\(s\)
parent
\(l\),
which
cannot
happen.
will
with
section
\(2,2\)
generating
positive
trees,
which
introduces
\(l\)
node
\(s\)
extending
tree
with
\(2\)
nodes
where
\(s\)
parent
\(l\).
Next,
take
care
next
cases
section
\(0,
0\).
also
expressed
using
sections
\(1,
\(1,
1\):
\begin{lstlisting}
c.define_class(1)
c.define_section(0)
visitor
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["l",
kind]
left
right
[(None,
"*")]
visitor
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["l",
parent_kind]
[left[0]
("*",)]
left[1:]
right
[None]
visitor
c.append_r_class_left_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["l",
parent_kind]
left
[right[0]
("*",)]
right[1:]
[None]
c.define_section(1)
visitor
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
(None,
"*"),
parent_kind]
left
right
visitor
c.append_r_class_left_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
parent_kind]
left
[right[0]
("*",)]
right[1:]
visitor
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
parent_kind]
[left[0]
("*",)]
left[1:]
right
\end{lstlisting}
Basically,
each
virtual
leaf
being
root
(i.e.~having
left
right
parent),
point
\(l\)
\(s\)
respectively
above
parent.
\includeinlinesvg{.32}{lambda__trees_111__1_base}%
\(\Rightarrow\)
\includeinlinesvg{.32}{lambda__trees_101__0}%
\includeinlinesvg{.32}{lambda__trees_112__0}%
last
generated
using
section
\(2,
0\):
\begin{lstlisting}
c.define_class(2)
c.define_section(0)
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
"o",
(None,
"*"),
None,
kind]
left
right
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
"o",
None,
(None,
"*"),
kind]
left
right
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
kind]
left
right
["o",
(None,
"*"),
None]
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
kind]
left
right
["o",
None,
(None,
"*")]
\end{lstlisting}
each
actual
vertex,
\(a\)
node
left
right
parent
a~second
child
\(o\)
node
sibling.
then
point
left
right
virtual
child
newly
created
\(o\)
node.
\includeinlinesvg{.20}{lambda__trees_200__0_base}%
\(\Rightarrow\)
\includeinlinesvg{.20}{lambda__trees_200__0}%
\includeinlinesvg{.20}{lambda__trees_201__0}%
\includeinlinesvg{.20}{lambda__trees_202__0}%
\includeinlinesvg{.20}{lambda__trees_203__0}%
After
such
transformations,
following
statistics:
\begin{lstlisting}
Classes
stats
0,0:
1,0:
1,1:
2,0:
[ao]
2,1:
[ll]
2,2:
[ls]
2,3:
[ss]
3,0:
[aos]
3,1:
[lls]
3,2:
[lss]
4,0:
[llss]
Diff
stats
1,0:
1,1:
\end{lstlisting}
This
construction
works
also
bigger
\(N\):
\begin{lstlisting}
Classes
stats
0,0:
39050
39050
1,0:
-23237
-23237
1,1:
-17799
-24460
2,0:
-13728
-13728
[ao]
2,1:
3432
[ll]
2,2:
14586
[ls]
2,3:
3861
[ss]
3,0:
4620
[aos]
3,1:
-2156
[lls]
3,2:
-2310
[lss]
4,0:
[llss]
Diff
stats
1,0:
7602
1,1:
5832
2,0:
2280
\end{lstlisting}
process
then
repeated
each
section.
have
chosen
lexicographical
order
(i.e.~\(0,0\);
\(1,0\);
\(1,1\);
\(2,0\);
\(\ldots\)).
\subsection{Final
result}%
\label{sub:final_result}
After
multiple
iterations,
managed
come
with
following
construction:
\begin{lstlisting}
c.define_class(0)
c.define_section(0)
c.append_r_class_subtree_visitor(1,
lambda
kind,
left,
right:
None
kind[0]
None
else
[kind
("*",
left
right
c.define_class(1)
c.define_section(0)
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["l",
kind]
left
right
[(None,
"*")]
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["l",
parent_kind]
[left[0]
("*",)]
left[1:]
right
[None]
c.append_r_class_left_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["l",
parent_kind]
left
[right[0]
("*",)]
right[1:]
[None]
c.define_section(1)
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
(None,
"*"),
parent_kind]
left
right
c.append_r_class_left_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
parent_kind]
left
[right[0]
("*",)]
right[1:]
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
parent_kind]
[left[0]
("*",)]
left[1:]
right
c.define_class(2)
c.define_section(0)
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
"o",
(None,
"*"),
None,
kind]
left
right
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
"o",
None,
(None,
"*"),
kind]
left
right
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
kind]
left
right
["o",
(None,
"*"),
None]
c.append_r_class_subtree_visitor(-1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["a",
kind]
left
right
["o",
None,
(None,
"*")]
c.define_section(1)
c.append_r_class_subtree_visitor(1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["l",
"l",
kind]
left
right
[(None,
"*"),
None]
c.define_section(2)
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["l",
"s",
(None,
"*"),
parent_kind]
left
right
[None]
c.append_r_class_subtree_visitor(1,
lambda
kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"l",
kind]
left
right
[(None,
"*")]
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"l",
parent_kind]
left
right
[(None,
"*")]
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"l",
parent_kind]
[left[0]
("*",
left[1:]
right
[None]
c.append_r_class_left_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"l",
parent_kind]
left
[right[0]
("*",
right[1:]
[None]
c.define_section(3)
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"s",
(None,
"*"),
parent_kind]
left
right
c.define_class(3)
c.define_section(0)
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"a",
"o",
(None,
"*"),
None,
parent_kind]
left
right
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"a",
"o",
None,
(None,
"*"),
parent_kind]
left
right
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"a",
parent_kind]
left
right
["o",
(None,
"*"),
None]
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"a",
parent_kind]
left
right
["o",
None,
(None,
"*")]
c.define_section(1)
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"l",
"l",
parent_kind]
left
right
[(None,
"*"),
None]
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
["s",
None,
"l",
"l",
parent_kind]
left
right
[(None,
"*"),
None]
c.define_section(2)
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"s",
None,
"l",
parent_kind]
left
right
[(None,
"*")]
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"l",
"s",
(None,
"*"),
parent_kind]
left
right
[None]
c.define_class(4)
c.define_section(0)
c.append_r_class_right_parent_subtree_visitor(1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
"s",
None,
"l",
"l",
parent_kind]
left
right
[(None,
"*"),
None]
\end{lstlisting}
resulted
final
statistics:
\begin{lstlisting}
Classes
stats
0,0:
39050
39050
1,0:
-23237
-23237
1,1:
-17799
-24460
2,0:
-13728
-13728
[ao]
2,1:
3432
3432
[ll]
2,2:
10833
14586
[ls]
2,3:
1770
3861
[ss]
3,0:
2280
4620
[aos]
3,1:
-1648
-2156
[lls]
3,2:
-1140
-2310
[lss]
4,0:
[llss]
Diff
stats
\end{lstlisting}
see,
diff
stats
empty,
managed
generate
expected
trees
both
sides
equation.
also
note
that
generate
trees
suggested
recurrence.
This
cheat
used.
\subsection{The
cheat}%
\label{sub:the_cheat}
remember
assumptions
Section~\ref{sub:the_framework}
about
discrimination
cases.
allowed
ourselves
apply
visitors
only
left
right
children,
which
handled
holonomic
recurrence
number
such
vertices
does
depend
only
\(n\).
this,
example
construction
section
\(1,
generate
expected
trees
from
then
repeat
iteration
order
generate
matching
trees
other
side
equation.
that
used
\(2\)
constructions
visiting
nodes
with
right
parent
only
visiting
node
having
left
parent,
missing
construction
should
also
visit
nodes
with
left
parent.
\begin{lstlisting}
c.define_class(1)
c.define_section(0)
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
(None,
"*"),
parent_kind]
left
right
c.append_r_class_left_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
parent_kind]
left
[right[0]
("*",)]
right[1:]
c.append_r_class_right_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
None,
parent_kind]
[left[0]
("*",)]
left[1:]
right
example
missing
construction
c.append_r_class_left_parent_subtree_visitor(-1,
lambda
kind,
parent_kind,
left,
right:
None
kind[0]
None
else
["s",
(None,
"*"),
parent_kind]
left
right
\end{lstlisting}
Please
note
that
only
an~example
missing
construction.
just
simplest
could
think
about,
that
case,
a~simple
solution
most
often
correct
one.
\section{Further
work}%
\label{sec:further_work}
First
thing
done,
that
comes
mind
immediately,
finish
construction
eliminating
cheat
mentioned
Section~\ref{sub:the_cheat}.
also
note
that
operating
specific
\(N\).
probability
that
miss
some
corner
case
low,
even
check
large
\(N\)
values,
always
present.
formal
algebraic
proof
would
make
sure
that
construction
works.
would
prioritize
finishing
construction
first.
framework
also
perfect.
highly
depends
operator's
intuition.
believe
that
solving
process
automated.
simplest
method
that
comes
mind
simply
creating
heuristic
rules
that
then
will
used
framework
guess
least
partial
solutions.
With
proper
interpretation,
possible
create
a~sampling
algorithm
similar
my's
binary
trees~\cite{remy,note}.
would
have
take
under
consideration
that
some
trees
being
removed
other
classes,
probabilities
would
have
carefully.
believe
that
that
will
done
proven
impossible.
\clearpage
\printbibliography%
\end{document}
